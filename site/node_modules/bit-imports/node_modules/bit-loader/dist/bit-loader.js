/*! bit-loader v0.2.5 - 2015-06-26. (c) 2015 Miguel Castillo. Licensed under MIT */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.bitloader = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
var matcher = require('./matcher');


/**
 * Provides functioanlity for aggregating matching rules that can
 * then be compared against a criteria to determine if the criteria
 * is met. The matching rules can be customized beyond simple string
 * comparison. Please take a look at {@link matchers}
 *
 * @class
 *
 * @param {Object} [options={}] - Settings for the rule to be created
 */
function Rule(options) {
  options = options || {};
  this._name  = Rule.configureName(options.name);
  this._match = Rule.configureMatch(options.match);
}


var ruleId = 0;

/**
 * Helper method to generate rule names.
 *
 * @returns {string} Name of the rule
 */
Rule.configureName = function(name) {
  return name || ('rule-' + ruleId++);
};


/**
 * Helper method to generate rules that can be executed to match criteria.
 *
 * @param {*} match - If match is a function, then we just call that function
 *  to do the comparison for us. Provide a function when looking to customize
 *  how criteria are matched to rules. If match is not a function, the rule
 *  matcher is used. The default rule matcher is generally sufficient. But if
 *  it is not, then provide a function.  Furthermore, match can be an array
 *  of matching rules.
 *
 * @returns {Array.<Rule>} array of configured rule matchers.
 */
Rule.configureMatch = function(match) {
  match = match || [];
  match = !(match instanceof Array) ? [match] : match;

  return match.map(function(item) {
    return (item && item.constructor === Function) ? item : matcher(item);
  });
};


/**
 * Method that returns the name of the rule
 *
 * @returns {string} Name of the rule
 */
Rule.prototype.getName = function() {
  return this._name;
};


Rule.prototype.getLength = function() {
  return this._match.length;
};


/**
 * Method to add a match to the list of matching rules
 *
 * @param {*} match - Matching rules to add. Can any type.
 *
 * @returns {Rule} this instance.
 */
Rule.prototype.addMatcher = function(match) {
  this._match = this._match.concat(Rule.configureMatch(match));
  return this;
};


/**
 * Method to match only *one* rule
 *
 * @param {string} criteria - Input to test against.
 *
 * @returns {boolean} True if any rule is matched, false otherwise
 */
Rule.prototype.match = Rule.prototype.matchAny = function(criteria) {
  var matches = this._match;
  var i, length;
  for (i = 0, length = matches.length; i < length; i++) {
    if (Rule.__match(matches[i], criteria)) {
      return true;
    }
  }
  return false;
};


/**
 * Method to test againt *all* rules
 *
 * @param {string} criteria - Input to test against
 *
 * @returns {boolean} True is *all* rules match, false otherwise
 */
Rule.prototype.matchAll = function(criteria) {
  var matches = this._match;
  var i, length;
  for (i = 0, length = matches.length; i < length; i++) {
    if (!Rule.__match(matches[i], criteria)) {
      return false;
    }
  }
  return true;
};


/**
 * Function that call the matcher with the criteria.
 *
 * @private
 * @returns {boolean}
 */
Rule.__match = function(match, criteria) {
  try {
    return match(criteria);
  }
  catch(ex) {
  }

  return false;
};


Rule.matcher = matcher;
module.exports = Rule;

},{"./matcher":2}],2:[function(require,module,exports){
/**
 * Default matching rule with strict comparison. Or if the match is a regex
 * then the comparison is done by calling the `test` method on the regex.
 *
 * @param {*} match - If the input is a regex, then matches will be done using
 *  the regex itself. Otherwise, the comparison is done with strict comparison.
 *
 * @returns {boolean}
 */
function matcher(match) {
  if (match instanceof RegExp) {
    return function(criteria) {
      return match.test(criteria);
    };
  }

  return function(criteria) {
    return criteria === match;
  };
}


/**
 * Matcher for file extensions.
 *
 * @param {string} match - extensions to match. You can provide a pipe delimeted
 *  string to specify multiple extensions.  E.g. "js|jsx" will match js and jsx
 *  file extensions.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
matcher.extension = function(match) {
  if (match === '' || typeof match !== 'string') {
    throw new TypeError('Matching rule must be a string');
  }

  match = new RegExp('\\.(' + match + ')$');
  return function(criteria) {
    return match.test(criteria);
  };
};


/**
 * Matcher for strings. Use this to do strict comparison on strings.
 *
 * @param {string} match - String to match a criteria against.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
matcher.string = function(match) {
  if (typeof match !== 'string') {
    throw new TypeError('Match type must be a string');
  }

  return function(criteria) {
    return match === criteria;
  };
};


/**
 * Matcher for regex. Use this to create regex that can be used for matching
 * criteria.
 *
 * @param {string|RegExp} match - The input can be a string, which is converted
 *  to a regex. The input can also be a regex. This matcher will make sure we
 *  are working with regex matching rules.
 *
 * @returns {function} Predicate that takes the criteria to match and returns
 *  true or false.
 */
matcher.regex = function(match) {
  if (match !== '' && typeof match === 'string') {
    match = new RegExp(match);
  }

  if (!(match instanceof RegExp)) {
    throw new TypeError('Match type must be a string or a regex');
  }

  return function(criteria) {
    return match.test(criteria);
  };
};


module.exports = matcher;

},{}],3:[function(require,module,exports){
var Rule       = require("roolio");
var Logger     = require("./logger");
var Utils      = require("./utils");
var Fetcher    = require("./interfaces/fetcher");
var Compiler   = require("./interfaces/compiler");
var Resolver   = require("./interfaces/resolver");
var Import     = require("./import");
var Loader     = require("./loader");
var Module     = require("./module");
var Plugin     = require("./plugin");
var Registry   = require("./registry");
var Middleware = require("./middleware");

var getRegistryId = Registry.idGenerator("bitloader");


/**
 * @class
 *
 * Facade for relevant interfaces to register and import modules
 */
function Bitloader(options) {
  options = options || {};

  this.settings = options;
  this.context  = Registry.getById(getRegistryId());
  this.plugins  = {};

  this.rules = {
    ignore: {
      fetch: new Rule(),
      transform: new Rule(),
      dependency: new Rule(),
      compile: new Rule()
    }
  };

  this.pipelines = {
    resolve    : new Middleware(this),
    fetch      : new Middleware(this),
    transform  : new Middleware(this),
    dependency : new Middleware(this),
    compile    : new Middleware(this)
  };

  // Override any of these factories if you need specialized implementation
  this.providers = {
    // Internal helper that can be overriden
    loader   : new Bitloader.Loader(this),
    importer : new Bitloader.Import(this)
  };

  // Public Interface
  var providers = this.providers;

  // Module loader hooks
  this.resolve  = options.resolve || (new Bitloader.Resolver()).resolve;
  this.fetch    = options.fetch   || (new Bitloader.Fetcher()).fetch;
  this.compile  = options.compile || (new Bitloader.Compiler()).compile;

  // Internal helpers
  this.load     = providers.loader.load.bind(providers.loader);
  this.register = providers.loader.register.bind(providers.loader);
  this.import   = providers.importer.import.bind(providers.importer);

  // Register plugins
  for (var plugin in options.plugins) {
    this.plugin(plugin, options.plugins[plugin]);
  }

  // Register pipeline options.
  for (var pipeline in options.pipelines) {
    if (this.pipelines.hasOwnProperty(pipeline)) {
      this.pipelines[pipeline].use(options.pipelines[pipeline]);
    }
  }
}


/**
 * Method that converts a module name to a path to the module file.
 *
 * @param {string} name - Name of the module to generate a path for
 * @param {{path: string, name: string}} referer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise} Promise that when resolved, will return an object with
 *  a required field `path` where we can load the module file from.
 */
Bitloader.prototype.resolve = function(){};


/**
 * Method to read files from storage. This is to be implemented by the code
 * making use of Bitloader.
 *
 * @param {string} name - Name of the module whose file content needs to be
 *  fetched.
 * @param {{path: string, name: string}} referer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise} Promise that when resolved, a module meta object
 *  with a "source" property is returned. The "source" property is where
 *  the content of the file is stored.
 */
Bitloader.prototype.fetch = function(){};


/**
 * Method for asynchronously loading modules.
 *
 * @returns {Pormise} That when resolved, it returns the full instance of the
 *  module loaded
 */
Bitloader.prototype.load = function(){};


/**
 * Method to asynchronously load modules
 *
 * @param {string|Array.<string>} names - Module or list of modules names to
 *  load. These names map back to the paths settings Bitloader was created
 *  with.
 *
 * @returns {Promise} That when resolved, all the imported modules are passed
 *  back as arguments.
 */
Bitloader.prototype.import = function(){};


/**
 * Method that converts source file to a module code that can be consumed by
 * the host application.
 *
 * @returns {Module} Module instance with code that can be consumed by the host
 *  application.
 */
Bitloader.prototype.compile = function(){};


/**
 * Method to define a module to be asynchronously loaded via the
 * [import]{@link Bitloader#import} method
 *
 * @param {string} name - Name of the module to register
 * @param {Array.<string>} deps - Collection of dependencies to be loaded and
 *  passed into the factory callback method.
 * @param {Function} factory - Function to be called in order to instantiate
 *  (realize) the module
 */
Bitloader.prototype.register = function(){};


/**
 * Clears the context, which means that all cached modules and other pertinent data
 * will be deleted.
 */
Bitloader.prototype.clear = function() {
  this.context.clear();
};


/**
 * Checks if the module instance is in the module registry
 */
Bitloader.prototype.hasModule = function(name) {
  return this.context.hasModule(name) || this.providers.loader.isLoaded(name);
};


/**
 * Returns the module instance if one exists.  If the module instance isn't in the
 * module registry, then a TypeError exception is thrown
 */
Bitloader.prototype.getModule = function(name) {
  if (!this.hasModule(name)) {
    throw new TypeError("Module `" + name + "` has not yet been loaded");
  }

  if (!this.context.hasModule(name)) {
    return this.context.setModule(Module.State.LOADED, name, this.providers.loader.syncBuild(name));
  }

  return this.context.getModule(name);
};


/**
 * Add a module instance to the module registry.  And if the module already exists in
 * the module registry, then a TypeError exception is thrown.
 *
 * @param {Module} mod - Module instance to add to the module registry
 *
 * @returns {Module} Module instance added to the registry
 */
Bitloader.prototype.setModule = function(mod) {
  var name = mod.name;

  if (!(mod instanceof(Module))) {
    throw new TypeError("Module `" + name + "` is not an instance of Module");
  }

  if (!name || typeof(name) !== "string") {
    throw new TypeError("Module must have a name");
  }

  if (this.context.hasModule(name)) {
    throw new TypeError("Module instance `" + name + "` already exists");
  }

  return this.context.setModule(Module.State.LOADED, name, mod);
};


/**
 * Interface to delete a module from the registry.
 *
 * @param {string} name - Name of the module to delete
 *
 * @returns {Module} Deleted module
 */
Bitloader.prototype.deleteModule = function(name) {
  if (!this.context.hasModule(name)) {
    throw new TypeError("Module instance `" + name + "` does not exists");
  }

  return this.context.deleteModule(name);
};


/**
 * Returns the module code from the module registry. If the module code has not
 * yet been fully compiled, then we defer to the loader to build the module and
 * return the code.
 *
 * @param {string} name - The name of the module code to get from the module registry
 *
 * @return {object} The module code.
 */
Bitloader.prototype.getModuleCode = function(name) {
  if (!this.hasModule(name)) {
    throw new TypeError("Module `" + name + "` has not yet been loaded");
  }

  return this.getModule(name).code;
};


/**
 * Sets module evaluated code directly in the module registry.
 *
 * @param {string} name - The name of the module, which is used by other modules
 *  that need it as a dependency.
 * @param {object} code - The evaluated code to be set
 *
 * @returns {object} The evaluated code.
 */
Bitloader.prototype.setModuleCode = function(name, code) {
  if (this.hasModule(name)) {
    throw new TypeError("Module code for `" + name + "` already exists");
  }

  var mod = new Module({
    name: name,
    code: code
  });

  return this.setModule(mod).code;
};


/**
 * Checks is the module has been fully finalized, which is when the module instance
 * get stored in the module registry
 */
Bitloader.prototype.isModuleCached = function(name) {
  return this.context.hasModule(name);
};


/**
 * Add ignore rules for configuring what the different pipelines shoud not process.
 *
 * @param {Object} rule - Rule configuration
 * @returns {Bitloader} Bitloader instance
 */
Bitloader.prototype.ignore = function(rule) {
  if (!rule) {
    throw new TypeError("Must provide a rule configuration");
  }

  var i, length, ruleNames;

  // Simplify the arguments that can be passed in to the ignore method
  if (rule instanceof Array || typeof(rule) === "string") {
    rule = {
      match: rule
    };
  }

  if (!rule.name) {
    ruleNames = ["transform", "dependency"];
  }
  else {
    if (rule.name === "*") {
      ruleNames = Object.keys(this.rules.ignore);
    }
    else {
      ruleNames = Utils.isArray(rule.name) ? rule.name : [rule.name];
    }
  }

  for (i = 0, length = ruleNames.length; i < length; i++) {
    this.rules.ignore[ruleNames[i]].addMatcher(rule.match);
  }

  return this;
};


/**
 * Registers plugins into the pipeline.
 *
 * @param {string} name - Name of the plugin
 * @param {object} options - Object whose keys are the name of the particular
 *  pipeline they intend to register with. For example, if the plugin is to
 *  register a `transform` and a `dependency` pipeline handler, then the
 *  plugin object will have entries with those names. E.g.
 *
 *  ``` javascript
 *  var pluginDefinition = {
 *    "transform": function(meta) {
 *      console.log(meta);
 *    },
 *    "dependency": function(meta) {
 *      console.log(meta);
 *    }
 *  };
 *
 *  bitlaoder.plugin(plugin);
 *  ```
 */
Bitloader.prototype.plugin = function(name, options) {
  if (Utils.isPlainObject(name)) {
    options = name;
    name = null;
  }

  var plugin;

  // If plugin exists, then we get it so that we can update it with the new settings.
  // Otherwise we create a new plugin and configure it with the incoming settings.
  if (this.plugins.hasOwnProperty(name)) {
    plugin = this.plugins[name];
  }
  else {
    plugin = new Plugin(name, this);
    this.plugins[plugin.name] = plugin;
  }

  var handlers = [];
  function handlerVisitor(handlerConfig) {
    if (handlerConfig.deferred) {
      handlers.push(handlerConfig.deferred);
    }
  }

  plugin.configure(options, handlerVisitor);

  // Add plugin handlers to ignore list.
  if (handlers.length) {
    this.ignore({match: handlers});
  }

  return plugin;
};


/**
 * Method to check if a plugin already exists.
 */
Bitloader.prototype.hasPlugin = function(name) {
  return this.plugins.hasOwnProperty(name);
};


/**
 * Method to get a plugin that has already been loaded.
 */
Bitloader.prototype.getPlugin = function(name) {
  if (this.plugins.hasOwnProperty(name)) {
    throw new TypeError("Plugin '" + name + "' not found");
  }

  return this.plugins[name];
};


// Expose constructors and utilities
Bitloader.Utils      = Utils;
Bitloader.Registry   = Registry;
Bitloader.Loader     = Loader;
Bitloader.Import     = Import;
Bitloader.Module     = Module;
Bitloader.Plugin     = Plugin;
Bitloader.Resolver   = Resolver;
Bitloader.Fetcher    = Fetcher;
Bitloader.Compiler   = Compiler;
Bitloader.Middleware = Middleware;
Bitloader.Rule       = Rule;
Bitloader.Logger     = Logger;
module.exports       = Bitloader;

},{"./import":4,"./interfaces/compiler":5,"./interfaces/fetcher":6,"./interfaces/resolver":7,"./loader":8,"./logger":9,"./middleware":17,"./module":18,"./plugin":20,"./registry":22,"./utils":24,"roolio":1}],4:[function(require,module,exports){
var Promise  = require("./promise");
var Utils    = require("./utils");
var Registry = require("./registry");

var getRegistryId = Registry.idGenerator("import");

var ModuleState = {
  IMPORTING: "importing"
};


/**
 * Module importer. Primary function is to load Module instances and resolving
 * their dependencies in order to make the Module fully consumable.
 */
function Import(manager) {
  if (!manager) {
    throw new TypeError("Must provide a manager");
  }

  this.manager = manager;
  this.context = Registry.getById(getRegistryId());
}


/**
 * Import is the method to load a Module
 *
 * @param {Array<string> | string} names - module(s) to import
 *
 * @returns {Promise}
 */
Import.prototype.import = function(name, options) {
  var importer = this;

  if (typeof(name) === "string") {
    return Promise.resolve(importer._getModule(name, options));
  }

  return Promise.all(name.map(function getModuleByName(name) {
    return importer._getModule(name, options);
  }));
};


/**
 * Gets the module by name.  If the module has not been loaded before, then
 * it is loaded via the module loader
 *
 * @param {Array<string>} names - Array of module names
 * @param {Object} options
 */
Import.prototype._getModule = function(name, options) {
  options = options || {};
  var importer = this;
  var manager  = this.manager;

  if (hasModule(options.modules, name)) {
    return options.modules[name];
  }
  else if (manager.hasModule(name)) {
    return manager.getModuleCode(name);
  }
  else if (importer.hasModule(name)) {
    return importer.getModule(name);
  }

  // Wrap in a separate promise to handle this:
  // https://github.com/MiguelCastillo/spromise/issues/35
  return new Promise(function deferredModuleResolver(resolve, reject) {
    function moduleError(error) {
      reject(Utils.reportError(error));
    }

    function moduleLoaded(mod) {
      if (name !== mod.name) {
        return Promise.reject(new TypeError("Module name must be the same as the name used for loading the Module itself"));
      }

      importer.deleteModule(mod.name);
      resolve(manager.getModuleCode(mod.name));
    }

    importer.setModule(name, manager.load(name))
      .then(moduleLoaded, moduleError);
  });
};


function hasModule(target, name) {
  return target && target.hasOwnProperty(name);
}

Import.prototype.hasModule = function(name) {
  return this.context.hasModuleWithState(ModuleState.IMPORTING, name);
};

Import.prototype.getModule = function(name) {
  return this.context.getModuleWithState(ModuleState.IMPORTING, name);
};

Import.prototype.setModule = function(name, item) {
  return this.context.setModule(ModuleState.IMPORTING, name, item);
};

Import.prototype.deleteModule = function(name) {
  return this.context.deleteModule(name);
};

module.exports = Import;

},{"./promise":21,"./registry":22,"./utils":24}],5:[function(require,module,exports){
function Compiler() {
}

Compiler.prototype.compile = function(moduleMeta) {
  moduleMeta.configure({
    code: moduleMeta.source
  });
};

module.exports = Compiler;

},{}],6:[function(require,module,exports){
function Fetcher() {
}

Fetcher.prototype.fetch = function(/*moduleMeta*/) {
  throw new TypeError("Fetcher:fetch is not implemented, must be implemented by the consumer code");
};

module.exports = Fetcher;

},{}],7:[function(require,module,exports){
function Resolver() {
}

Resolver.prototype.resolve = function(moduleMeta) {
  moduleMeta.configure({
    cname: moduleMeta.name
  });
};

module.exports = Resolver;

},{}],8:[function(require,module,exports){
var Promise        = require("./promise");
var Module         = require("./module");
var Utils          = require("./utils");
var Pipeline       = require("./pipeline");
var Registry       = require("./registry");
var metaLinker     = require("./meta/linker");
var metaResolve    = require("./meta/resolve");
var metaFetch      = require("./meta/fetch");
var metaTransform  = require("./meta/transform");
var metaDependency = require("./meta/dependency");
var metaCompile    = require("./meta/compile");

var getRegistryId = Registry.idGenerator("loader");


/**
 * The purpose of Loader is to return full instances of Module.  Module instances
 * are stored in the manager's context to avoid loading the same module multiple times.
 * If the module is loaded, then we just return that.  If it has not bee loaded yet,
 * then we:
 *
 * 1. Fetch its source; remote server, local file system... You must specify a fetch
 *      provider to define how source files are retrieved
 * 2. Transform the source that was fetched.  This step enables processing of the
 *      source before it is compiled into an instance of Module.
 * 3. Compile the source that was fetched and transformed into a proper instance
 *      of Module
 * 4. Link the module
 */
function Loader(manager) {
  if (!manager) {
    throw new TypeError("Must provide a manager");
  }

  this.manager = manager;
  this.context = Registry.getById(getRegistryId());

  // Setup the pipeline
  this.pipeline = new Pipeline([
    metaResolve.pipeline,
    metaFetch.pipeline,
    metaTransform.pipeline,
    metaDependency.pipeline,
    metaCompile.pipeline
  ]);
}


/**
 * Handles the process of returning the instance of the Module if one exists, otherwise
 * the workflow for creating the instance is kicked off, which will eventually lead to
 * the creation of a Module instance
 *
 * The workflow is to take in a module name that needs to be loaded.  If a module with
 * the given name isn't loaded, then we fetch it.  The fetch call returns a promise, which
 * when resolved returns a moduleMeta. The moduleMeta is an intermediate object that contains
 * the module source from fetch and a compile method used for converting the source to an
 * instance of Module. The purporse for moduleMeta is to allow a tranformation pipeline to
 * process the raw source before building the final product - a Module instance. The
 * transformation pipeline allows us to do things like convert coffeescript to javascript.
 *
 * Primary workflow:
 * fetch     -> module name {string}
 * transform -> module meta {compile:fn, source:string}
 * load deps -> module meta {compile:fn, source:string}
 * compile module meta
 * link module
 *
 * @param {string} name - The name of the module to load.
 * @param {{path: string, name: string}} referer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise} - Promise that will resolve to a Module instance
 */
Loader.prototype.load = function(name, referer) {
  var loader  = this;
  var manager = this.manager;

  if (!name) {
    return Promise.reject(new TypeError("Must provide the name of the module to load"));
  }

  // Take a look if the module is already loaded
  if (manager.hasModule(name)) {
    return Promise.resolve(manager.getModule(name));
  }

  // Check if the module is fetched or registered
  if (loader.isLoaded(name) || loader.isPending(name)) {
    return Promise.resolve(build());
  }

  function build() {
    return loader.asyncBuild(name);
  }

  return loader
    .fetch(name, referer)
    .then(build, Utils.reportError);
};


/**
 * This method fetches the module meta from storage, if it is not already loaded.
 * The purpose for this method is to setup the module meta and all its dependencies
 * so that the module meta can be converted to an instance of Module synchronously.
 *
 * Use this method if the intent is to preload dependencies without actually compiling
 * module meta objects to instances of Module.
 *
 * @param {string} name - The name of the module to fetch.
 * @param {{path: string, name: string}} referer - Object with the
 *  location and name of the requesting module.
 *
 * @returns {Promise}
 */
Loader.prototype.fetch = function(name, referer) {
  var loader  = this;
  var manager = this.manager;

  if (!name) {
    return Promise.reject(new TypeError("Must provide the name of the module to fetch"));
  }

  // Take a look if the module is already loaded
  if (manager.hasModule(name)) {
    return Promise.resolve();
  }

  // Check if the module is being fetched
  if (loader.isLoading(name)) {
    return loader.getLoading(name);
  }

  function moduleMetaFinished(moduleMeta) {
    return loader.setLoaded(moduleMeta.name, moduleMeta);
  }

  // Make sure we have the props we need.
  if (referer) {
    referer = {
      name: referer.name,
      path: referer.path
    };
  }

  // Create module meta, set the referer, and start processing it.
  var moduleMeta = new Module.Meta({
    name: name,
    referer: referer
  });

  var loading = loader
    ._pipelineModuleMeta(moduleMeta)
    .then(moduleMetaFinished, Utils.reportError);

  return loader.setLoading(name, loading);
};


/**
 * Converts a module meta object to a full Module instance.
 *
 * @param {string} name - The name of the module meta to convert to an instance of Module.
 *
 * @returns {Module} Module instance from the conversion of module meta
 */
Loader.prototype.syncBuild = function(name) {
  if (this.manager.isModuleCached(name)) {
    return Promise.resolve(this.manager.getModule(name));
  }

  // Evaluates source
  this._compileModuleMeta(name);

  if (this.isPending(name)) {
    throw new TypeError("Unable to synchronously build dynamic module '" + name + "'");
  }
  else if (!this.isLoaded(name)) {
    throw new TypeError("Unable to synchronously build module '" + name + "'");
  }

  // Calls module factory
  return this._linkModuleMeta(name);
};


/**
 * Build module handling any async Module registration.  What this means is that if a module
 * is being loaded and it calls System.register to register itself, then it needs to be handled
 * as an async step because that could be loading other dependencies.
 *
 * @param {string} name - Name of the target Module
 *
 * @returns {Promise}
 */
Loader.prototype.asyncBuild = function(name) {
  var loader = this;

  if (this.manager.isModuleCached(name)) {
    return Promise.resolve(this.manager.getModule(name));
  }

  // Evaluates source
  this._compileModuleMeta(name);

  if (this.isLoaded(name)) {
    return Promise.resolve().then(function() {
      return loader._linkModuleMeta(name);
    }, Utils.reportError);
  }
  else if (!this.isPending(name)) {
    throw new TypeError("Unable to build '" + name + "'.");
  }


  //
  // Helper methods
  //

  var buildDependencies = function(moduleMeta) {
    var pending = moduleMeta.deps.map(function buildDependency(moduleName) {
      return loader.asyncBuild(moduleName);
    });

    return Promise.all(pending)
      .then(function dependenciesBuilt() {
        return moduleMeta;
      }, Utils.reportError);
  };

  var linkModuleMeta = function() {
    return loader._linkModuleMeta(name);
  };


  // Right here is where we handle dynamic registration of modules while are being loaded.
  // E.g. System.register to register a module that's being loaded
  return metaDependency.pipeline(loader.manager, loader.getModule(name))
    .then(buildDependencies, Utils.reportError)
    .then(linkModuleMeta, Utils.reportError);
};


/**
 * Interface to register a module meta that can be put compiled to a Module instance
 */
Loader.prototype.register = function(name, deps, factory, type) {
  if (this.manager.isModuleCached(name)) {
    throw new TypeError("Module '" + name + "' is already loaded");
  }

  this.setPending(name, new Module.Meta({
    name    : name,
    deps    : deps,
    factory : factory,
    type    : type
  }));
};


/**
 * Utility helper that runs a module meta object through the transformation workflow.
 * The module meta object passed *must* have a string source property, which is what
 * the transformation workflow primarily operates against.
 *
 * @param {object} moduleMeta - Module meta object with require `source` property that
 *  is processed by the transformation pipeline.
 *
 * @returns {Promise} That when resolved, the fully tranformed module meta is returned.
 *
 */
Loader.prototype.transform = function(moduleMeta) {
  if (!moduleMeta) {
    return Promise.reject(new TypeError("Must provide a module meta object"));
  }

  if (!Utils.isString(moduleMeta.source)) {
    throw Promise.reject(new TypeError("Must provide a source string property with the content to transform"));
  }

  moduleMeta.deps = moduleMeta.deps || [];
  return metaTransform.pipeline(this.manager, moduleMeta);
};


/**
 * Put a module meta object through the pipeline, which includes the transformation
 * and dependency loading stages.
 *
 * @param {Module.Meta} moduleMeta - Module meta object to run through the pipeline.
 *
 * @returns {Promise} that when fulfilled, the processed module meta object is returned.
 */
Loader.prototype.runPipeline = function(moduleMeta) {
  return this.pipeline
    .run(this.manager, moduleMeta)
    .then(pipelineFinished, Utils.reportError);

  function pipelineFinished() {
    return moduleMeta;
  }
};


/**
 * Verifies the state of the module meta object, and puts it though the processing
 * pipeline if it needs to be processed.
 *
 * If the module meta object has already been compiled, then we do not execute the
 * processing pipeline.
 *
 * @param {Module.Meta} moduleMeta - Module meta object to run through the pipeline.
 *
 * @returns {Promise} that when fulfilled, the processed module meta object is returned.
 */
Loader.prototype._pipelineModuleMeta = function(moduleMeta) {
  if (Module.Meta.isCompiled(moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  return this.runPipeline(moduleMeta);
};


/**
 * Convert a module meta object into a proper Module instance.
 *
 * @param {string} name - Name of the module meta object to be converted.
 *
 * @returns {Module}
 */
Loader.prototype._compileModuleMeta = function(name) {
  var moduleMeta;
  var manager = this.manager;

  // If the item is ready to be linked, we skip the compilation step
  if (this.isPending(name)) {
    return;
  }

  if (this.isLoaded(name)) {
    moduleMeta = this.getModule(name);
  }
  else if (this.manager.isModuleCached(name)) {
    throw new TypeError("Module `" + name + "` is already built");
  }
  else {
    throw new TypeError("Module `" + name + "` is not loaded yet. Make sure to call `load` or `fetch` prior to calling `linkModuleMeta`");
  }

  // Compile module meta to create a Module instance
  return metaCompile.compile(manager, moduleMeta);
};


/**
 * Finalizes a Module instance by pulling in all the dependencies and calling the module
 * factory method if available.  This is the very last stage of the Module building process
 *
 * @param {Module} mod - Module instance to link
 *
 * @returns {Module} Instance all linked
 */
Loader.prototype._linkModuleMeta = function(name) {
  var moduleMeta;
  var manager = this.manager;

  if (this.manager.isModuleCached(name)) {
    throw new TypeError("Module `" + name + "` is already built");
  }
  else if (this.isLoaded(name) || this.isPending(name)) {
    moduleMeta = this.deleteModule(name);
  }
  else {
    throw new TypeError("Module `" + name + "` is not loaded yet. Make sure to call `load` or `fetch` prior to calling `linkModuleMeta`");
  }

  // Run the Module instance through the module linker
  var mod = metaLinker(manager, moduleMeta);

  // Set compiled module
  manager.setModule(mod);

  // We are all done here.
  return mod;
};


/**
 * Check if there is currently a module loading or loaded.
 *
 * @param {string} name - The name of the module meta to check
 *
 * @returns {Boolean}
 */
Loader.prototype.hasModule = function(name) {
  return this.context.hasModule(name);
};


/**
 * Method to retrieve the module meta with the given name, if one exists.  If it
 * is loading, then the promise for the pending request is returned. Otherwise
 * the actual module meta object is returned.
 *
 * @param {string} name - The name of the module meta to get
 *
 * @returns {object | Promise}
 */
Loader.prototype.getModule = function(name) {
  return this.context.getModule(name);
};


/**
 * Checks if the module meta with the given name is currently loading
 *
 * @param {string} name - The name of the module meta to check
 *
 * @returns {Boolean} - true if the module name is being loaded, false otherwise.
 */
Loader.prototype.isLoading = function(name) {
  return this.context.hasModuleWithState(Module.State.LOADING, name);
};


/**
 * Method to retrieve the module meta with the given name, if it is loading.
 *
 * @param {string} name - The name of the loading module meta to get.
 *
 * @returns {Promise}
 */
Loader.prototype.getLoading = function(name) {
  return this.context.getModuleWithState(Module.State.LOADING, name);
};


/**
 * Method to set the loading module meta with the given name.
 *
 * @param {string} name - The name of the module meta to set
 * @param {Object} item - The module meta to set
 *
 * @returns {Object} The module meta being set
 */
Loader.prototype.setLoading = function(name, item) {
  return this.context.setModule(Module.State.LOADING, name, item);
};


/**
 * Method to check if a module meta object is in a pending state, which means
 * that all it needs is have its dependencies loaded and then it's ready to
 * to be compiled.
 *
 * @param {string} name - Name of the module meta object
 *
 * @returns {Boolean}
 */
Loader.prototype.isPending = function(name) {
  return this.context.hasModuleWithState(Module.State.PENDING, name);
};


/**
 * Method to get a module meta object to the pending state.
 *
 * @param {string} name - Name of the module meta to get
 *
 * @returns {Object} Module meta object
 */
Loader.prototype.getPending = function(name) {
  return this.context.getModuleWithState(Module.State.PENDING, name);
};


/**
 * Method to set a module meta object to the pending state.
 *
 * @param {string} name - Name of the module meta object
 * @param {Object} item - Module meta object to be set
 *
 * @returns {Object} Module meta being set
 */
Loader.prototype.setPending = function(name, item) {
  return this.context.setModule(Module.State.PENDING, name, item);
};


/**
 * Method to check if a module meta with the given name is already loaded.
 *
 * @param {string} name - The name of the module meta to check.
 *
 * @returns {Boolean}
 */
Loader.prototype.isLoaded = function(name) {
  return this.context.hasModuleWithState(Module.State.LOADED, name);
};


/**
 * Method to retrieve the module meta with the given name, if one exists.
 *
 * @param {string} name - The name of the loaded module meta to set
 *
 * @returns {Object} The loaded module meta
 */
Loader.prototype.getLoaded = function(name) {
  return this.context.getModuleWithState(Module.State.LOADED, name);
};


/**
 * Method to set the loaded module meta with the given name
 *
 * @param {string} name - The name of the module meta to set
 * @param {Object} item - The module meta to set
 *
 * @returns {Object} The module meta being set
 */
Loader.prototype.setLoaded = function(name, item) {
  return this.context.setModule(Module.State.LOADED, name, item);
};


/**
 * Method to remove the module from storage
 *
 * @param {string} name - The name of the module meta to remove
 *
 * @returns {Object} The module meta being removed
 */
Loader.prototype.deleteModule = function(name) {
  return this.context.deleteModule(name);
};


module.exports = Loader;

},{"./meta/compile":10,"./meta/dependency":11,"./meta/fetch":12,"./meta/linker":13,"./meta/resolve":14,"./meta/transform":16,"./module":18,"./pipeline":19,"./promise":21,"./registry":22,"./utils":24}],9:[function(require,module,exports){
var _enabled = false;
var _only    = false;


/**
 * @class
 * Logger instance with a name
 *
 * @param {string} name - Name of the logger
 */
function Logger(name, options) {
  options = options || {};
  this._enabled  = true;
  this.name      = name;

  configureStream(this, options);
  configureSerializer(this, options);
}


/**
 * Helper factory method to create named loggers
 */
Logger.prototype.factory = function(name, options) {
  return new Logger(name, options);
};


/**
 * Method to log a message.
 *
 * Verifies that logger is enabled. If it is enabled, then the message(s) are
 * logged. Otherwise ignored.
 */
Logger.prototype.log = function() {
  if (!this.isEnabled()) {
    return;
  }

  var data = {date: getDate(), type: "log", name: this.name, data: arguments};
  (Logger.stream || this.stream).write((Logger.serialize || this.serialize)(data));
};


/**
 * Method to log errors.
 *
 * Verifies that the logger is enabled. If it is enabled, then the error(s)
 * are logged.  Otherwise ignored.
 */
Logger.prototype.error = function() {
  if (!this.isEnabled()) {
    return;
  }

  var data = {date: getDate(), type: "error", name: this.name, data: arguments};
  (Logger.stream || this.stream).write((Logger.serialize || this.serialize)(data));
};


/**
 * Method to log warnings.
 *
 * Verifies that the logger is enabled. If it is enabled, then the warnings(s)
 * are logged.  Otherwise ignored.
 */
Logger.prototype.warn = function() {
  if (!this.isEnabled()) {
    return;
  }

  var data = {date: getDate(), type: "warn", name: this.name, data: arguments};
  (Logger.stream || this.stream).write((Logger.serialize || this.serialize)(data));
};


/**
 * Method to log informational message.
 *
 * Verifies that the logger is enabled. If it is enabled, then the info(s)
 * are logged.  Otherwise ignored.
 */
Logger.prototype.info = function() {
  if (!this.isEnabled()) {
    return;
  }

  var data = {date: getDate(), type: "info", name: this.name, data: arguments};
  (Logger.stream || this.stream).write((Logger.serialize || this.serialize)(data));
};


/**
 * Method to be overiden to give custom behavior.
 */
Logger.prototype.serialize = function(data) {
  return data;
};


/**
 * Checks if the logger can write messages.
 *
 * @returns {boolean}
 */
Logger.prototype.isEnabled = function() {
  return this._enabled && _enabled && (!_only || _only === this.name);
};


/**
 * Method to enable the logger intance. If loggers have been disabled
 * globally then this flag will not have an immediate effect, until
 * loggers are globally enabled.
 */
Logger.prototype.enable = function() {
  this._enabled = true;
};


/**
 * Method to disable the logger instance. Like {@link Logger#enable},
 * this setting does not have an immediate effect if loggers are globally
 * disabled.
 */
Logger.prototype.disable = function() {
  this._enabled = false;
};


/**
 * Method to make sure only this logger logs messages. If another logger is
 * set to only, then the request is silently ignored.
 */
Logger.prototype.only = function() {
  if (!Logger._only) {
    Logger._only = this.name;
  }
};


/**
 * Method to remove the logger from the `only` state to allow other loggers
 * set themselves as only.
 */
Logger.prototype.all = function() {
  Logger._only = null;
};


/**
 * Disables loggers globally.
 */
Logger.prototype.disableAll = function() {
  Logger.disable();
};


/**
 * Enables loggers globally.
 */
Logger.prototype.enableAll = function() {
  Logger.enable();
};


// Expose the constructor to be able to create new instances from an
// existing instance.
Logger.prototype.default = Logger;


/**
 * Underlying method to enable all logger instances
 *
 * @private
 */
Logger.enable  = function() {
  _enabled = true;
};


/**
 * Underlying method to disable all logger instances
 *
 * @private
 */
Logger.disable = function() {
  _enabled = false;
};


/**
 * Underlying method to set the `only` logger instance that can log message
 *
 * @private
 */
Logger.only = function(name) {
  _only = name;
};


/**
 * Underlying method to remove the `only` logger instance that can log
 * message
 *
 * @private
 */
Logger.all = function() {
  _only = null;
};


/**
 * Returns a valid console interface with three methods:
 *
 * @returns {{write: function}}
 */
function getConsoleStream() {
  var result;
  if (typeof(console) !== "undefined") {
    result = console;
  }

  return result && {
    write: function(data) {
      result.log(data);
    }
  };
}


/**
 * Gets defaul process.stdout when running in node.
 */
function getProcessStream() {
  var result;
  if (typeof(process) !== "undefined" && process.stdout) {
    result = process.stdout;
  }

  return result && {
    write: function(data) {
      result.write(data);
    }
  };
}


/**
 * Get a noop stream
 */
function getNoopStream() {
  return {
    write: function() {}
  };
}


/**
 * Method that fills in the target object to make sure we have a valid target
 * we are writing to.
 */
function configureStream(logger, options) {
  logger.stream = options.stream || getConsoleStream() || getProcessStream() || getNoopStream();
}


/**
 * Handler custom serializers
 */
function configureSerializer(logger, options) {
  if (options.serialize) {
    logger.serialize = options.serialize;
  }
  else if (typeof(process) !== "undefined" && process.stdout) {
    logger.serialize = function(data) {
      if (typeof(data) !== "string") {
        data = JSON.stringify(data);
      }
      return data;
    };
  }
}


/**
 * Helper method to get timestamps for logged message
 *
 * @private
 */
function getDate() {
  return (new Date()).getTime();
}


/**
 * Default logger instance available
 */
module.exports = new Logger();

},{}],10:[function(require,module,exports){
var runPipeline = require("./runPipeline");
var Promise     = require("../promise");
var Module      = require("../module");
var Utils       = require("../utils");
var logger      = require("../logger").factory("Meta/Compiler");


function MetaCompile() {
}


/**
 * Runs compiler pipeline to give plugins a chances to compile the meta module
 * if one is registered.
 *
 * This step is asynchronous.
 */
MetaCompile.pipeline = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (!Module.Meta.canCompile(moduleMeta) || !canProcess(manager, moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  function compilationFinished() {
    return moduleMeta;
  }

  return runPipeline(manager.pipelines.compile, moduleMeta)
    .then(compilationFinished, Utils.reportError);
};


/**
 * The compile step evaluates the module meta source.
 *
 * This step is synchronous.
 */
MetaCompile.compile = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (canProcess(manager, moduleMeta) && Module.Meta.canCompile(moduleMeta)) {
    moduleMeta.configure(manager.compile(moduleMeta));
  }
};


function canProcess(manager, moduleMeta) {
  return !manager.rules.ignore.compile.match(moduleMeta.name);
}


module.exports = MetaCompile;

},{"../logger":9,"../module":18,"../promise":21,"../utils":24,"./runPipeline":15}],11:[function(require,module,exports){
var runPipeline = require("./runPipeline");
var Promise     = require("../promise");
var Module      = require("../module");
var Utils       = require("../utils");
var logger      = require("../logger").factory("Meta/Dependency");


function MetaDependency() {
}


/**
 * Runs dependency pipeline to load up all dependencies for the module
 *
 * @returns {Function} callback to call with the Module instance with the
 *   dependencies to be resolved
 */
MetaDependency.pipeline = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (!canProcess(manager, moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  function dependenciesFinished() {
    // Return if the module has no dependencies
    if (Module.Meta.hasDependencies(moduleMeta)) {
      return loadDependencies(manager, moduleMeta);
    }

    return moduleMeta;
  }

  return runPipeline(manager.pipelines.dependency, moduleMeta)
    .then(dependenciesFinished, Utils.reportError);
};


function loadDependencies(manager, moduleMeta) {
  var i, length, loading = new Array(moduleMeta.deps.length);

  for (i = 0, length = moduleMeta.deps.length; i < length; i++) {
    loading[i] = manager.providers.loader.fetch(moduleMeta.deps[i], moduleMeta);
  }

  function dependenciesFetched() {
    return moduleMeta;
  }

  return Promise.all(loading).then(dependenciesFetched, Utils.reportError);
}


function canProcess(manager, moduleMeta) {
  return !manager.rules.ignore.dependency.match(moduleMeta.name);
}


module.exports = MetaDependency;

},{"../logger":9,"../module":18,"../promise":21,"../utils":24,"./runPipeline":15}],12:[function(require,module,exports){
var runPipeline = require("./runPipeline");
var Promise     = require("../promise");
var Utils       = require("../utils");
var logger      = require("../logger").factory("Meta/Fetch");


function MetaFetch() {
}


/**
 * Runs fetch pipeline to give plugins a chance to load the meta source
 */
MetaFetch.pipeline = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (!canProcess(manager, moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  function fetchFinished() {
    // If a pipeline item has added source to the module meta, then we
    // are done with this stage.  Otherwise, we will run the default
    // fetch provider
    if (Utils.isString(moduleMeta.source)) {
      return moduleMeta;
    }

    return MetaFetch.fetch(manager, moduleMeta);
  }

  return runPipeline(manager.pipelines.fetch, moduleMeta)
    .then(fetchFinished, Utils.reportError);
};


/**
 * Fetch source using default fetch
 */
MetaFetch.fetch = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (!canProcess(manager, moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  return Promise.resolve(manager.fetch(moduleMeta))
    .then(function(meta) {
      return moduleMeta.configure(meta);
    }, Utils.reportError);
};


function canProcess(manager, moduleMeta) {
  return !Utils.isString(moduleMeta.source) && !manager.rules.ignore.fetch.match(moduleMeta.name);
}


module.exports = MetaFetch;

},{"../logger":9,"../promise":21,"../utils":24,"./runPipeline":15}],13:[function(require,module,exports){
var Module = require("../module");
var logger = require("../logger").factory("Module/Linker");


/**
 * The linker step is where we take the evaluated source, build all the dependencies
 * and call the factory method on the module if available.
 *
 * This is the step where the Module instance is finally created.
 *
 * @returns {Module}
 */
function MetaLinker(manager, moduleMeta) {
  // Make this is compiled or can be linked.
  if (!Module.Meta.isCompiled(moduleMeta)) {
    throw new TypeError("Module " + moduleMeta.name + " cannot be linked");
  }

  function traverseDependencies(mod) {
    logger.log(mod.name, mod);

    // Get all dependencies to feed them to the module factory
    var deps = mod.deps.map(function resolveDependency(mod_name) {
      if (mod.meta && mod.meta.builtins && mod.meta.builtins.hasOwnProperty(mod_name)) {
        return mod.meta.builtins[mod_name];
      }

      if (manager.isModuleCached(mod_name)) {
        return manager.getModuleCode(mod_name);
      }

      return traverseDependencies(manager.getModule(mod_name)).code;
    });

    if (mod.factory && !mod.hasOwnProperty("code")) {
      mod.code = mod.factory.apply(undefined, deps);
    }

    return mod;
  }

  // Create module instance...
  var _module = new Module(moduleMeta);

  // We will coerce the name no matter what name (if one at all) the Module was
  // created with. This will ensure a consistent state in the loading engine.
  _module.name = moduleMeta.name;

  // Set the mod.meta for convenience
  _module.meta = moduleMeta;

  // Link it
  return traverseDependencies(_module);
}

module.exports = MetaLinker;

},{"../logger":9,"../module":18}],14:[function(require,module,exports){
var runPipeline = require("./runPipeline");
var Promise     = require("../promise");
var Utils       = require("../utils");
var logger      = require("../logger").factory("Meta/Resolve");


function MetaResolve() {
}


MetaResolve.pipeline = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  function resolveFinished() {
    if (moduleMeta.hasOwnProperty("path")) {
      return moduleMeta;
    }

    return MetaResolve.resolve(manager, moduleMeta);
  }

  return runPipeline(manager.pipelines.resolve, moduleMeta)
    .then(resolveFinished, Utils.reportError);
};


MetaResolve.resolve = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  return Promise.resolve(manager.resolve(moduleMeta))
    .then(function(meta) {
      meta = meta || {};
      if (!meta.cname) {
        meta.cname = meta.name || meta.path;
      }

      delete meta.name;
      return moduleMeta.configure(meta);
    }, Utils.reportError);
};


module.exports = MetaResolve;

},{"../logger":9,"../promise":21,"../utils":24,"./runPipeline":15}],15:[function(require,module,exports){
var Plugin = require("../plugin");

function runPipeline(pipeline, moduleMeta) {
  if (runPlugins(moduleMeta.plugins)) {
    return pipeline.run(moduleMeta.plugins, moduleMeta, Plugin.createCanExecute(moduleMeta));
  }
  else {
    return pipeline.runAll(moduleMeta, Plugin.createCanExecute(moduleMeta));
  }
}

function runPlugins(plugins) {
  return plugins && plugins.length && !(plugins.length === 1 && !plugins[0]);
}

module.exports = runPipeline;

},{"../plugin":20}],16:[function(require,module,exports){
var runPipeline = require("./runPipeline");
var Promise     = require("../promise");
var Utils       = require("../utils");
var logger      = require("../logger").factory("Meta/Transform");


function MetaTransform() {
}


/**
 * The transform enables transformation providers to process the moduleMeta
 * before it is compiled into an actual Module instance.  This is where steps
 * such as linting and processing coffee files can take place.
 */
MetaTransform.pipeline = function(manager, moduleMeta) {
  logger.log(moduleMeta.name, moduleMeta);

  if (!canProcess(manager, moduleMeta)) {
    return Promise.resolve(moduleMeta);
  }

  function transformationFinished() {
    return moduleMeta;
  }

  return runPipeline(manager.pipelines.transform, moduleMeta)
    .then(transformationFinished, Utils.reportError);
};


function canProcess(manager, moduleMeta) {
  return Utils.isString(moduleMeta.source) && !manager.rules.ignore.transform.match(moduleMeta.name);
}


module.exports = MetaTransform;

},{"../logger":9,"../promise":21,"../utils":24,"./runPipeline":15}],17:[function(require,module,exports){
var Promise = require("./promise");
var Utils   = require("./utils");
var logger  = require("./logger").factory("Middleware");


/**
 * @constructor For checking middleware provider instances
 */
function Provider() {
}


/**
 * Method that determines if the handler should be called and then calls
 * if need be.
 *
 * @returns {Promise} Promise returned from the call to the handler.
 */
Provider.prototype.execute = function(data) {
  if (Utils.isFunction(this.handler)) {
    return this.handler.apply(this, data);
  }
};


/**
 * Middleware provides a mechanism for registering `plugins` that can be
 * called in the order in which they are registered.  These middlewares can
 * be module names that can be loaded at runtime or can be functions.
 */
function Middleware(options) {
  this.settings  = options || {};
  this.providers = [];
  this.named     = {};
}


/**
 * Method to register middleware providers. Providers can be methods, a module name,
 * or an object.
 *
 * For example, the provider below is just a method that will get invoked when
 * running the entire sequence of providers. The provider is registered as an
 * anonymous provider.
 *
 * ``` javascript
 * middleware.use(function() {
 *   console.log("1");
 * });
 * ```
 *
 * But registering a provider as a name will cause the middleware engine to
 * dynamically load it at runtime, and can also be executed by name.
 *
 * ``` javascript
 * middleware.use(`concat`);
 * middleware.run(`concat`);
 * ```
 *
 * The alternative for registering named providers is to pass in a `Object` with a
 * `handler` method and a `name`.  The name is only required if you are interested in
 * more control for executing the provider.
 *
 * ``` javascript
 * middleware.use({
 *  name: "concat",
 *  handler: function() {
 *  }
 * });
 *
 * // Will only run `concat`
 * middleware.run(`concat`);
 *
 * // Will run all registered providers, including `concat`
 * middleware.runAll();
 * ```
 *
 * @param {Object | Array<Object>} providers - One or collection of providers to
 *   be registered in this middleware instance.
 *
 * @returns {Middleware} Returns instance of Middleware
 */
Middleware.prototype.use = function(providers) {
  if (!Utils.isArray(providers)) {
    providers = [providers];
  }

  var i, length, provider, options;
  for (i = 0, length = providers.length; i < length; i++) {
    options = providers[i];

    if (!options) {
      throw new TypeError("Middleware provider must not be empty");
    }

    if (this.hasProvider(options.name)) {
      Middleware.configureProvider(this, this.getProvider(options.name), options);
    }
    else {
      provider = Middleware.createProvider(this, options);
      this.providers.push(provider);

      if (Utils.isString(provider.name)) {
        this.named[provider.name] = provider;
      }
    }
  }

  return this;
};


/**
 * Gets the middleware provider by name.  It also handles when the middlware
 * handler does not exist.
 *
 * @returns {Provider}
 */
Middleware.prototype.getProvider = function(name) {
  if (!this.named.hasOwnProperty(name)) {
    throw new TypeError("Middleware provider '" + name + "' does not exist");
  }

  return this.named[name];
};


/**
 * Determines whether or not the provider with the specific name is already
 * registered.
 *
 * @param {string} name - Name of the provider.
 * @returns {boolean} Whether or not the named provider is already registered
 */
Middleware.prototype.hasProvider = function(name) {
  return this.named.hasOwnProperty(name);
};


/**
 * Creates an array of Providers from the array of names
 *
 * @param {string | Array.<string>} names - Name of collection of provider names
 *   to be returned in an array of providers.
 *
 * @returns {Array.<Provider>} Array of providers.
 */
Middleware.prototype.filterProviders = function(names) {
  if (Utils.isString(names)) {
    names = [names];
  }

  if (!Utils.isArray(names)) {
    throw new TypeError("List of handlers must be a string or an array of names");
  }

  var i, length;
  var providers = [];

  for (i = 0, length = names.length; i < length; i++) {
    if (this.hasProvider(names[i])) {
      providers.push(this.getProvider(names[i]));
    }
  }

  return providers;
};


/**
 * Method that runs `named` providers.  You can pass in a name of the provider
 * to be executed or an array of names.  If passing in an array, the providers
 * will be executed in the order in which they are in the array; regardless of
 * the order in which they were registered.
 *
 * @param {string | Array<string>} names - Name(s) of the providers to run
 *
 * @returns {Promise}
 */
Middleware.prototype.run = function(names, data, canExecuteProvider) {
  if (data && !Utils.isArray(data)) {
    data = [data];
  }

  var providers = this.filterProviders(names);
  return _runProviders(providers, data, canExecuteProvider);
};


/**
 * Method that runs the first found `named` provider.  You can pass in a name of
 * the provider to be executed or an array of names to chose from.
 *
 * @param {string | Array<string>} names - Name(s) of the providers to run
 *
 * @returns {Promise}
 */
Middleware.prototype.runFirst = function(names, data, canExecuteProvider) {
  if (data && !Utils.isArray(data)) {
    data = [data];
  }

  var providers = this.filterProviders(names).shift();
  return _runProviders(providers ? [providers] : [], data, canExecuteProvider);
};


/**
 * Method to run all registered providers in the order in which they were
 * registered.
 *
 * @returns {Promise}
 */
Middleware.prototype.runAll = function(data, canExecuteProvider) {
  if (data && !Utils.isArray(data)) {
    data = [data];
  }

  return _runProviders(this.providers, data, canExecuteProvider);
};


/**
 * @private
 *
 * Method to configure providers.
 */
Middleware.configureProvider = function(middleware, provider, options) {
  if (Utils.isFunction(provider.configure)) {
    provider.configure(options);
  }
  if (Utils.isFunction(options)) {
    provider.handler = options;
  }
  else if (Utils.isString(options)) {
    provider.name = options;

    if (!Utils.isFunction(provider.handler)) {
      provider.handler = Middleware.deferredHandler(middleware, provider);
    }
  }
  else if (Utils.isPlainObject(options)) {
    if (!Utils.isFunction(options.handler) && !Utils.isFunction(provider.handler)) {
      if (Utils.isString(options.name)) {
        options.handler = Middleware.deferredHandler(middleware, provider);
      }
      else {
        throw new TypeError("Middleware provider must have a handler method or a name");
      }
    }

    Utils.extend(provider, options);
  }

  return provider;
};


/**
 * @private
 *
 * Provider factory
 */
Middleware.createProvider = function(middleware, options) {
  var provider;

  if (Utils.isFunction(options) || Utils.isString(options) || Utils.isPlainObject(options)) {
    provider = Middleware.configureProvider(middleware, new Provider(), options);
  }

  return provider || options;
};


/**
 * @private
 *
 * Method that enables chaining in providers that have to be dynamically loaded.
 */
Middleware.deferredHandler = function(middleware, provider) {
  if (!middleware.settings.import) {
    throw new TypeError("You must configure an import method in order to dynamically load middleware providers");
  }

  function importProvider() {
    if (!provider.__deferred) {
      logger.log("import [start]", provider);
      provider.__deferred = middleware.settings
        .import(provider.name)
        .then(providerImported, Utils.reportError);
    }
    else {
      logger.log("import [pending]", provider);
    }

    return provider.__deferred;
  }

  function providerImported(result) {
    logger.log("import [end]", provider);
    delete provider.__deferred;
    Middleware.configureProvider(middleware, provider, result);
  }


  return function deferredHandlerDelegate() {
    var data = arguments;

    // Callback when provider is loaded
    function providerReady() {
      return provider.execute(data);
    }

    return importProvider().then(providerReady, Utils.reportError);
  };
};


/**
 * @private
 *
 * Method that runs a cancellable sequence of promises.
 *
 * When a provider is executed, sequence execution can be terminated by returning
 * false. You can also `throw` to teminate the execution.
 *
 * The only thing a provider can return is a promise, which is really useful
 * if the provider needs to do some work asynchronously.
 */
function _runProviders(providers, data, canExecuteProvider) {
  // Method that runs the sequence of providers
  function providerSequence(result, provider) {
    var cancelled = false;

    function providerSequenceRun(result) {
      if (result === false) {
        cancelled = true;
      }

      if (!cancelled) {
        if (!canExecuteProvider || (canExecuteProvider && canExecuteProvider(provider) !== false)) {
          return provider.execute(data);
        }
      }
    }

    function providerSequenceError(err) {
      cancelled = true;
      return Utils.reportError(err);
    }

    return result.then(providerSequenceRun, providerSequenceError);
  }

  return providers.reduce(providerSequence, Promise.resolve());
}


Middleware.Provider = Provider;
module.exports = Middleware;

},{"./logger":9,"./promise":21,"./utils":24}],18:[function(require,module,exports){
var Utils = require("./utils");

var Type = {
  "UNKNOWN" : "UNKNOWN",
  "AMD"     : "AMD",     //Asynchronous Module Definition
  "CJS"     : "CJS",     //CommonJS
  "IIFE"    : "IIFE"     //Immediately-Invoked Function Expression
};


/**
 * - Loading means that the module meta is currently being loaded. Only for ASYNC
 *  processing.
 *
 * - Loaded means that the module meta is all processed and it is ready to be
 *  built into a Module instance. Only for SYNC processing.
 *
 * - Pending means that the module meta is already loaded, but it needs it's
 *  dependencies processed, which might lead to further loading of module meta
 *  objects. Only for ASYNC processing.
 */
var State = {
  LOADING: "loading",
  LOADED:  "loaded",
  PENDING: "pending"
};


function Module(options) {
  if (!options) {
    throw new TypeError("Must provide options to create the module");
  }

  if (options.hasOwnProperty("code")) {
    this.code = options.code;
  }

  if (options.hasOwnProperty("factory")) {
    this.factory = options.factory;
  }

  this.type = options.type || Type.UNKNOWN;
  this.id   = options.id || options.name;
  this.name = options.name;
  this.deps = options.deps ? options.deps.slice(0) : [];
}


/**
 * Module meta object
 */
function Meta(options) {
  options = options || {};

  if (Utils.isString(options)) {
    options = {
      name: options
    };
  }

  // Make sure we have a an ID for the module meta
  options.id = options.id || options.name;

  if (!Utils.isString(options.name)) {
    throw new TypeError("Must provide a name, which is used by the resolver to create a location for the resource");
  }

  if (!Utils.isArray(options.deps)) {
    delete options.deps;
    this.deps = [];
  }

  this.configure(options);
}


Meta.prototype.configure = function(options) {
  return Utils.extend(this, options);
};


/**
 * Verifies that the module meta object is either already compiled or can be compiled.
 *
 * @returns {boolean}
 */
Meta.validate = function(moduleMeta) {
  if (!moduleMeta) {
    throw new TypeError("Must provide options");
  }

  if (!Meta.isCompiled(moduleMeta) && !Meta.canCompile(moduleMeta)) {
    throw new TypeError("ModuleMeta must provide a `source` string or `code`.");
  }
};


/**
 * Verifies is the module meta object has dependencies.
 *
 * @returns {boolean}
 */
Meta.hasDependencies = function(moduleMeta) {
  return moduleMeta.deps && moduleMeta.deps.length;
};


/**
 * A module meta object is considered compiled if it has a `code` or `factory` method.
 * That's because those are the two things that the compile step actually generates
 * before creating a Module instance.
 *
 * @returns {boolean}
 */
Meta.isCompiled = function(moduleMeta) {
  return moduleMeta.hasOwnProperty("code") || Utils.isFunction(moduleMeta.factory);
};


/**
 * Checks if the module meta object can be compiled by verifying that it has NOT
 * already been compiled and that it has a `source` property that need to be compiled.
 *
 * @returns {boolean}
 */
Meta.canCompile = function(moduleMeta) {
  return !Meta.isCompiled(moduleMeta) && Utils.isString(moduleMeta.source);
};


Module.Meta  = Meta;
Module.Type  = Type;
Module.State = State;
module.exports = Module;

},{"./utils":24}],19:[function(require,module,exports){
var Promise = require("./promise");
var Utils   = require("./utils");

function Pipeline(assets) {
  this.assets = assets;
}

Pipeline.prototype.run = function() {
  var args = arguments;
  function cb(curr) {
    return function pipelineAssetReady() {
      return curr.apply((void 0), args);
    };
  }

  return this.assets.reduce(function(prev, curr) {
    return prev.then(cb(curr), Utils.reportError);
  }, Promise.resolve());
};

module.exports = Pipeline;

},{"./promise":21,"./utils":24}],20:[function(require,module,exports){
var Promise = require("./promise");
var Utils   = require("./utils");
var Rule    = require("roolio");

var pluginId = 0;


/**
 * Plugin
 */
function Plugin(name, options) {
  options = options || {};
  this.name       = name || ("plugin-" + (pluginId++));
  this.settings   = options;
  this.services   = options.services || options.pipelines;
  this._matches   = {};
  this._delegates = {};
  this._handlers  = {};
}


/**
 * Configure plugin
 */
Plugin.prototype.configure = function(options, handlerVisitor) {
  var settings = Utils.merge({}, options);

  // Add matching rules
  for (var matchName in settings.match) {
    if (!settings.match.hasOwnProperty(matchName)) {
      continue;
    }

    this.addMatchingRules(matchName, settings.match[matchName]);
  }

  // Hook into the different services
  for (var serviceName in settings) {
    if (!settings.hasOwnProperty(serviceName) || serviceName === "match") {
      continue;
    }

    this.addHandlers(serviceName, settings[serviceName], handlerVisitor);
  }

  return this;
};


/**
 * Method for adding matching rules used for determining if a
 * module meta should be processed by the plugin or not.
 */
Plugin.prototype.addMatchingRules = function(matchName, matches) {
  var rules;
  if (matches && matches.length) {
    rules = this._matches[matchName] || (this._matches[matchName] = new Rule({name: matchName}));
    rules.addMatcher(matches);
  }

  return this;
};


/**
 * Adds handlers for the particular service.
 */
Plugin.prototype.addHandlers = function(serviceName, handlers, visitor) {
  if (!this.services.hasOwnProperty(serviceName)) {
    throw new TypeError("Unable to register plugin for '" + serviceName + "'. '" + serviceName + "' is not found");
  }

  // Make sure we have a good plugin's configuration settings for the service.
  this._handlers[serviceName] = configurePluginHandlers(this, handlers, visitor);

  // Register service delegate if one does not exist.  Delegates are the callbacks
  // registered with the service that when called, the plugins executes all the
  // plugin's handlers in a promise sequence.
  if (!this._delegates[serviceName]) {
    this._delegates[serviceName] = createServiceHandler(this, serviceName);
    registerServiceHandler(this, this.services[serviceName], this._delegates[serviceName]);
  }

  return this;
};


/**
 * Register service handler delegate
 */
function registerServiceHandler(plugin, service, handler) {
  service.use({
    name    : plugin.name,
    match   : plugin._matches,
    handler : handler
  });
}


/**
 * Creates service handler to process module meta objects
 */
function createServiceHandler(plugin, serviceName) {
  // The service handler iterates through all the plugin handlers
  // passing in the correspoding module meta to be processed.
  return function handlerDelegate(moduleMeta) {
    // This is a nasty little sucker with nested layers of promises...
    // Handlers themselves can return promises and get injected into
    // the promise sequence.
    function handlerIterator(prev, handlerConfig) {
      function pluginHandler() {
        return handlerConfig.handler.call(handlerConfig, moduleMeta, handlerConfig.options);
      }
      return prev.then(pluginHandler, Utils.reportError);
    }

    return plugin._handlers[serviceName].reduce(handlerIterator, Promise.resolve());
  };
}


/**
 * Function that goes through all the handlers and configures each one. This is
 * where handle things like if a handler is a string, then we assume it is the
 * name of a module that we need to load...
 */
function configurePluginHandlers(plugin, handlers, visitor) {
  if (!handlers) {
    throw new TypeError("Plugin must have 'handlers' defined");
  }

  if (!Utils.isArray(handlers)) {
    handlers = [handlers];
  }

  return handlers.map(function handlerIterator(handlerConfig) {
    var handlerName;

    if (!handlerConfig) {
      throw new TypeError("Plugin handler must be a string, a function, or an object with a handler that is a string or a function");
    }

    if (Utils.isFunction(handlerConfig) || Utils.isString(handlerConfig)) {
      handlerConfig = {
        handler: handlerConfig
      };
    }

    // Handle dynamic handler loading
    if (Utils.isString(handlerConfig.handler)) {
      handlerName = handlerConfig.handler;
      handlerConfig.deferred = handlerName;
      handlerConfig.handler = deferredHandler;
    }

    if (!Utils.isFunction(handlerConfig.handler)) {
      throw new TypeError("Plugin handler must be a function or a string");
    }

    function deferredHandler(moduleMeta) {
      if (handlerConfig.pending) {
        return;
      }

      // Set a pending flag so that we do not add this same deferred handler to
      // the same sequence, which causes a deadlock.
      handlerConfig.pending = handlerName;
      function handlerReady(newhandler) {
        delete handlerConfig.pending; // Cleanup the pending field.
        handlerConfig.handler = newhandler;
        return newhandler.call(handlerConfig, moduleMeta, handlerConfig.options);
      }

      return deferredPluginHandler(plugin, handlerName)
        .then(handlerReady, Utils.reportError);
    }

    // Once the plugin handler is configured, call the visitor callback if one is provided.
    if (visitor) {
      visitor(handlerConfig);
    }

    return handlerConfig;
  });
}


/**
 * Create a handler delegate that when call, it loads a module to be used
 * as the actualhandler used in a service.
 */
function deferredPluginHandler(plugin, handlerName) {
  if (!plugin.settings.import) {
    throw new TypeError("You must configure an import method in order to dynamically load plugin handlers");
  }

  return plugin.settings.import(handlerName);
}


/**
 * Checks if the handler can process the module meta object based on
 * the matching rules for path and name.
 */
function canExecute(matches, moduleMeta) {
  var ruleLength, allLength = 0;

  for (var match in matches) {
    if (!moduleMeta.hasOwnProperty(match) || !matches.hasOwnProperty(match)) {
      continue;
    }

    ruleLength = matches[match].getLength();
    allLength += ruleLength;

    if (ruleLength && matches[match].match(moduleMeta[match])) {
      return true;
    }
  }

  // If there was no matching rule, then we will return true.  That's because
  // if there weren't any rules put in place to restrict module processing,
  // then the assumption is that the module can be processed.
  return !allLength;
}


function createCanExecute(moduleMeta) {
  return function canExecuteDelegate(plugin) {
    return canExecute(plugin.match, moduleMeta);
  };
}


Plugin.canExecute       = canExecute;
Plugin.createCanExecute = createCanExecute;
module.exports = Plugin;

},{"./promise":21,"./utils":24,"roolio":1}],21:[function(require,module,exports){
(function() {
  "use strict";
  module.exports = Promise;
})();

},{}],22:[function(require,module,exports){
var StatefulItems = require("./stateful-items");
var storage = {};


/**
 * Module registry
 */
function Registry(options) {
  options = options || {};
  this._id     = options.id || generateId();
  this.modules = options.modules || new StatefulItems();
}


Registry.prototype.clear = function() {
  if (storage.hasOwnProperty(this._id)) {
    delete storage[this._id];
  }
  return this;
};


Registry.prototype.hasModule = function(name) {
  return this.modules.hasItem(name);
};


Registry.prototype.getModule = function(name) {
  return this.modules.getItem(name);
};


Registry.prototype.deleteModule = function(name) {
  return this.modules.removeItem(name);
};


Registry.prototype.setModule = function(state, name, item) {
  return this.modules.setItem(state, name, item);
};


Registry.prototype.getModuleState = function(name) {
  return this.modules.getState(name);
};


Registry.prototype.hasModuleWithState = function(state, name) {
  return this.modules.hasItemWithState(state, name);
};


Registry.prototype.getModuleWithState = function(state, name) {
  return this.modules.getItemWithState(state, name);
};


/**
 * Factory method that creates Registries with an id
 */
Registry.getById = function(id) {
  if (!id) {
    id = generateId();
  }

  return storage[id] || (storage[id] = new Registry({id: id}));
};


/**
 * Destroys Registries by id.
 */
Registry.clearById = function(id) {
  if (storage.hasOwnProperty(id)) {
    return storage[id].clear();
  }
};


/**
 * Creates a named id generator you can use for prefixing generated ids. The
 * idea is that you can generate ids you prefix in order to group generated
 * ids.
 *
 * @param {string} name - Name of the id generator. Provide you to
 *   customize the ids generated. Defaults to 'generic'.
 * @parem {number} seed - Seed number to start id generation from.
 *
 * @returns {function} That when called creates and returns a new
 *   unique id.
 */
Registry.idGenerator = function(name, seed) {
  name = (name || "generic") + "-";
  var id = seed || 0;
  return function createId() {
    return name + id++;
  };
};


var generateId = Registry.idGenerator();
module.exports = Registry;

},{"./stateful-items":23}],23:[function(require,module,exports){
function StatefulItems(items) {
  this.items = items || {};
}


/**
 * Helper methods for CRUD operations on `items` map for based on their StateTypes
 */


StatefulItems.prototype.getState = function(name) {
  if (!this.hasItem(name)) {
    throw new TypeError("`" + name + "` not found");
  }

  return this.items[name].state;
};


StatefulItems.prototype.hasItemWithState = function(state, name) {
  return this.hasItem(name) && this.items[name].state === state;
};


StatefulItems.prototype.getItemWithState = function(state, name) {
  if (!this.hasItemWithState(state, name)) {
    throw new TypeError("`" + name + "` is not " + state);
  }

  return this.items[name].item;
};


StatefulItems.prototype.hasItem = function(name) {
  return this.items.hasOwnProperty(name);
};


StatefulItems.prototype.getItem = function(name) {
  if (!this.hasItem(name)) {
    throw new TypeError("`" + name + "` not found");
  }

  return this.items[name].item;
};


StatefulItems.prototype.removeItem = function(name) {
  if (!this.items.hasOwnProperty(name)) {
    throw new TypeError("`" + name + "` cannot be removed - not found");
  }

  var item = this.items[name];
  delete this.items[name];
  return item.item;
};


StatefulItems.prototype.setItem = function(state, name, item) {
  return (this.items[name] = {item: item, state: state}).item;
};


module.exports = StatefulItems;

},{}],24:[function(require,module,exports){
function noop() {
}

function isNil(item) {
  return item === null || item === (void 0);
}

function isNull(item) {
  return item === null;
}

function isArray(item) {
  return item instanceof Array;
}

function isString(item) {
  return typeof item === "string";
}

function isObject(item) {
  return typeof item === "object";
}

var ObjectSignature = Object.prototype.toString();
function isPlainObject(item) {
  return !!item && !isArray(item) && item.toString() === ObjectSignature;
}

function isFunction(item) {
  return !isNil(item) && item.constructor === Function;
}

function isDate(item) {
  return item instanceof Date;
}

function result(input, args, context) {
  if (isFunction(input) === "function") {
    return input.apply(context, args||[]);
  }
  return input[args];
}

function toArray(items) {
  if (isArray(items)) {
    return items;
  }

  return Object.keys(items).map(function(item) {
    return items[item];
  });
}

/**
 * Copies all properties from sources into target
 */
function extend(target) {
  var source, length, i;
  var sources = arguments;
  target = target || {};

  // Allow n params to be passed in to extend this object
  for (i = 1, length  = sources.length; i < length; i++) {
    source = sources[i];
    for (var property in source) {
      if (source.hasOwnProperty(property)) {
        target[property] = source[property];
      }
    }
  }

  return target;
}

/**
 * Deep copy of all properties into target
 */
function merge(target) {
  var source, length, i;
  var sources = arguments;
  target = target || {};

  // Allow `n` params to be passed in to extend this object
  for (i = 1, length  = sources.length; i < length; i++) {
    source = sources[i];
    for (var property in source) {
      if (!source.hasOwnProperty(property)) {
        continue;
      }

      if (isPlainObject(source[property])) {
        target[property] = merge(target[property], source[property]);
      }
      else {
        target[property] = source[property];
      }
    }
  }

  return target;
}


/**
 * Logs error to the console and makes sure it is only logged once.
 */
function reportError(error) {
  if (error && !error.handled) {
    error.handled = true;
    if (error.stack) {
      console.log(error.stack);
    }
    else {
      console.error(error);
    }
  }

  return error;
}


function forwardError(error) {
  return error;
}


function notImplemented(msg) {
  throw new TypeError("Not implemented. " + msg);
}


module.exports = {
  isNil: isNil,
  isNull: isNull,
  isArray: isArray,
  isString: isString,
  isObject: isObject,
  isPlainObject: isPlainObject,
  isFunction: isFunction,
  isDate: isDate,
  toArray: toArray,
  noop: noop,
  result: result,
  extend: extend,
  merge: merge,
  reportError: reportError,
  forwardError: forwardError,
  notImplemented: notImplemented
};

},{}]},{},[3])(3)
});