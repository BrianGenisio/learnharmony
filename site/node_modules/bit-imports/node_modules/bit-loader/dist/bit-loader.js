!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var f;"undefined"!=typeof window?f=window:"undefined"!=typeof global?f=global:"undefined"!=typeof self&&(f=self),f.bitloader=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

},{}],2:[function(require,module,exports){
module.exports = minimatch
minimatch.Minimatch = Minimatch

var path = { sep: '/' }
try {
  path = require('path')
} catch (er) {}

var GLOBSTAR = minimatch.GLOBSTAR = Minimatch.GLOBSTAR = {}
var expand = require('brace-expansion')

// any single thing other than /
// don't need to escape / when using new RegExp()
var qmark = '[^/]'

// * => any number of characters
var star = qmark + '*?'

// ** when dots are allowed.  Anything goes, except .. and .
// not (^ or / followed by one or two dots followed by $ or /),
// followed by anything, any number of times.
var twoStarDot = '(?:(?!(?:\\\/|^)(?:\\.{1,2})($|\\\/)).)*?'

// not a ^ or / followed by a dot,
// followed by anything, any number of times.
var twoStarNoDot = '(?:(?!(?:\\\/|^)\\.).)*?'

// characters that need to be escaped in RegExp.
var reSpecials = charSet('().*{}+?[]^$\\!')

// "abc" -> { a:true, b:true, c:true }
function charSet (s) {
  return s.split('').reduce(function (set, c) {
    set[c] = true
    return set
  }, {})
}

// normalizes slashes.
var slashSplit = /\/+/

minimatch.filter = filter
function filter (pattern, options) {
  options = options || {}
  return function (p, i, list) {
    return minimatch(p, pattern, options)
  }
}

function ext (a, b) {
  a = a || {}
  b = b || {}
  var t = {}
  Object.keys(b).forEach(function (k) {
    t[k] = b[k]
  })
  Object.keys(a).forEach(function (k) {
    t[k] = a[k]
  })
  return t
}

minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return minimatch

  var orig = minimatch

  var m = function minimatch (p, pattern, options) {
    return orig.minimatch(p, pattern, ext(def, options))
  }

  m.Minimatch = function Minimatch (pattern, options) {
    return new orig.Minimatch(pattern, ext(def, options))
  }

  return m
}

Minimatch.defaults = function (def) {
  if (!def || !Object.keys(def).length) return Minimatch
  return minimatch.defaults(def).Minimatch
}

function minimatch (p, pattern, options) {
  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}

  // shortcut: comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    return false
  }

  // "" only matches ""
  if (pattern.trim() === '') return p === ''

  return new Minimatch(pattern, options).match(p)
}

function Minimatch (pattern, options) {
  if (!(this instanceof Minimatch)) {
    return new Minimatch(pattern, options)
  }

  if (typeof pattern !== 'string') {
    throw new TypeError('glob pattern string required')
  }

  if (!options) options = {}
  pattern = pattern.trim()

  // windows support: need to use /, not \
  if (path.sep !== '/') {
    pattern = pattern.split(path.sep).join('/')
  }

  this.options = options
  this.set = []
  this.pattern = pattern
  this.regexp = null
  this.negate = false
  this.comment = false
  this.empty = false

  // make the set of regexps etc.
  this.make()
}

Minimatch.prototype.debug = function () {}

Minimatch.prototype.make = make
function make () {
  // don't do it more than once.
  if (this._made) return

  var pattern = this.pattern
  var options = this.options

  // empty patterns and comments match nothing.
  if (!options.nocomment && pattern.charAt(0) === '#') {
    this.comment = true
    return
  }
  if (!pattern) {
    this.empty = true
    return
  }

  // step 1: figure out negation, etc.
  this.parseNegate()

  // step 2: expand braces
  var set = this.globSet = this.braceExpand()

  if (options.debug) this.debug = console.error

  this.debug(this.pattern, set)

  // step 3: now we have a set, so turn each one into a series of path-portion
  // matching patterns.
  // These will be regexps, except in the case of "**", which is
  // set to the GLOBSTAR object for globstar behavior,
  // and will not contain any / characters
  set = this.globParts = set.map(function (s) {
    return s.split(slashSplit)
  })

  this.debug(this.pattern, set)

  // glob --> regexps
  set = set.map(function (s, si, set) {
    return s.map(this.parse, this)
  }, this)

  this.debug(this.pattern, set)

  // filter out everything that didn't compile properly.
  set = set.filter(function (s) {
    return s.indexOf(false) === -1
  })

  this.debug(this.pattern, set)

  this.set = set
}

Minimatch.prototype.parseNegate = parseNegate
function parseNegate () {
  var pattern = this.pattern
  var negate = false
  var options = this.options
  var negateOffset = 0

  if (options.nonegate) return

  for (var i = 0, l = pattern.length
    ; i < l && pattern.charAt(i) === '!'
    ; i++) {
    negate = !negate
    negateOffset++
  }

  if (negateOffset) this.pattern = pattern.substr(negateOffset)
  this.negate = negate
}

// Brace expansion:
// a{b,c}d -> abd acd
// a{b,}c -> abc ac
// a{0..3}d -> a0d a1d a2d a3d
// a{b,c{d,e}f}g -> abg acdfg acefg
// a{b,c}d{e,f}g -> abdeg acdeg abdeg abdfg
//
// Invalid sets are not expanded.
// a{2..}b -> a{2..}b
// a{b}c -> a{b}c
minimatch.braceExpand = function (pattern, options) {
  return braceExpand(pattern, options)
}

Minimatch.prototype.braceExpand = braceExpand

function braceExpand (pattern, options) {
  if (!options) {
    if (this instanceof Minimatch) {
      options = this.options
    } else {
      options = {}
    }
  }

  pattern = typeof pattern === 'undefined'
    ? this.pattern : pattern

  if (typeof pattern === 'undefined') {
    throw new Error('undefined pattern')
  }

  if (options.nobrace ||
    !pattern.match(/\{.*\}/)) {
    // shortcut. no need to expand.
    return [pattern]
  }

  return expand(pattern)
}

// parse a component of the expanded set.
// At this point, no pattern may contain "/" in it
// so we're going to return a 2d array, where each entry is the full
// pattern, split on '/', and then turned into a regular expression.
// A regexp is made at the end which joins each array with an
// escaped /, and another full one which joins each regexp with |.
//
// Following the lead of Bash 4.1, note that "**" only has special meaning
// when it is the *only* thing in a path portion.  Otherwise, any series
// of * is equivalent to a single *.  Globstar behavior is enabled by
// default, and can be disabled by setting options.noglobstar.
Minimatch.prototype.parse = parse
var SUBPARSE = {}
function parse (pattern, isSub) {
  var options = this.options

  // shortcuts
  if (!options.noglobstar && pattern === '**') return GLOBSTAR
  if (pattern === '') return ''

  var re = ''
  var hasMagic = !!options.nocase
  var escaping = false
  // ? => one single character
  var patternListStack = []
  var plType
  var stateChar
  var inClass = false
  var reClassStart = -1
  var classStart = -1
  // . and .. never match anything that doesn't start with .,
  // even when options.dot is set.
  var patternStart = pattern.charAt(0) === '.' ? '' // anything
  // not (start or / followed by . or .. followed by / or end)
  : options.dot ? '(?!(?:^|\\\/)\\.{1,2}(?:$|\\\/))'
  : '(?!\\.)'
  var self = this

  function clearStateChar () {
    if (stateChar) {
      // we had some state-tracking character
      // that wasn't consumed by this pass.
      switch (stateChar) {
        case '*':
          re += star
          hasMagic = true
        break
        case '?':
          re += qmark
          hasMagic = true
        break
        default:
          re += '\\' + stateChar
        break
      }
      self.debug('clearStateChar %j %j', stateChar, re)
      stateChar = false
    }
  }

  for (var i = 0, len = pattern.length, c
    ; (i < len) && (c = pattern.charAt(i))
    ; i++) {
    this.debug('%s\t%s %s %j', pattern, i, re, c)

    // skip over any that are escaped.
    if (escaping && reSpecials[c]) {
      re += '\\' + c
      escaping = false
      continue
    }

    switch (c) {
      case '/':
        // completely not allowed, even escaped.
        // Should already be path-split by now.
        return false

      case '\\':
        clearStateChar()
        escaping = true
      continue

      // the various stateChar values
      // for the "extglob" stuff.
      case '?':
      case '*':
      case '+':
      case '@':
      case '!':
        this.debug('%s\t%s %s %j <-- stateChar', pattern, i, re, c)

        // all of those are literals inside a class, except that
        // the glob [!a] means [^a] in regexp
        if (inClass) {
          this.debug('  in class')
          if (c === '!' && i === classStart + 1) c = '^'
          re += c
          continue
        }

        // if we already have a stateChar, then it means
        // that there was something like ** or +? in there.
        // Handle the stateChar, then proceed with this one.
        self.debug('call clearStateChar %j', stateChar)
        clearStateChar()
        stateChar = c
        // if extglob is disabled, then +(asdf|foo) isn't a thing.
        // just clear the statechar *now*, rather than even diving into
        // the patternList stuff.
        if (options.noext) clearStateChar()
      continue

      case '(':
        if (inClass) {
          re += '('
          continue
        }

        if (!stateChar) {
          re += '\\('
          continue
        }

        plType = stateChar
        patternListStack.push({ type: plType, start: i - 1, reStart: re.length })
        // negation is (?:(?!js)[^/]*)
        re += stateChar === '!' ? '(?:(?!' : '(?:'
        this.debug('plType %j %j', stateChar, re)
        stateChar = false
      continue

      case ')':
        if (inClass || !patternListStack.length) {
          re += '\\)'
          continue
        }

        clearStateChar()
        hasMagic = true
        re += ')'
        plType = patternListStack.pop().type
        // negation is (?:(?!js)[^/]*)
        // The others are (?:<pattern>)<type>
        switch (plType) {
          case '!':
            re += '[^/]*?)'
            break
          case '?':
          case '+':
          case '*':
            re += plType
            break
          case '@': break // the default anyway
        }
      continue

      case '|':
        if (inClass || !patternListStack.length || escaping) {
          re += '\\|'
          escaping = false
          continue
        }

        clearStateChar()
        re += '|'
      continue

      // these are mostly the same in regexp and glob
      case '[':
        // swallow any state-tracking char before the [
        clearStateChar()

        if (inClass) {
          re += '\\' + c
          continue
        }

        inClass = true
        classStart = i
        reClassStart = re.length
        re += c
      continue

      case ']':
        //  a right bracket shall lose its special
        //  meaning and represent itself in
        //  a bracket expression if it occurs
        //  first in the list.  -- POSIX.2 2.8.3.2
        if (i === classStart + 1 || !inClass) {
          re += '\\' + c
          escaping = false
          continue
        }

        // handle the case where we left a class open.
        // "[z-a]" is valid, equivalent to "\[z-a\]"
        if (inClass) {
          // split where the last [ was, make sure we don't have
          // an invalid re. if so, re-walk the contents of the
          // would-be class to re-translate any characters that
          // were passed through as-is
          // TODO: It would probably be faster to determine this
          // without a try/catch and a new RegExp, but it's tricky
          // to do safely.  For now, this is safe and works.
          var cs = pattern.substring(classStart + 1, i)
          try {
            RegExp('[' + cs + ']')
          } catch (er) {
            // not a valid class!
            var sp = this.parse(cs, SUBPARSE)
            re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]'
            hasMagic = hasMagic || sp[1]
            inClass = false
            continue
          }
        }

        // finish up the class.
        hasMagic = true
        inClass = false
        re += c
      continue

      default:
        // swallow any state char that wasn't consumed
        clearStateChar()

        if (escaping) {
          // no need
          escaping = false
        } else if (reSpecials[c]
          && !(c === '^' && inClass)) {
          re += '\\'
        }

        re += c

    } // switch
  } // for

  // handle the case where we left a class open.
  // "[abc" is valid, equivalent to "\[abc"
  if (inClass) {
    // split where the last [ was, and escape it
    // this is a huge pita.  We now have to re-walk
    // the contents of the would-be class to re-translate
    // any characters that were passed through as-is
    cs = pattern.substr(classStart + 1)
    sp = this.parse(cs, SUBPARSE)
    re = re.substr(0, reClassStart) + '\\[' + sp[0]
    hasMagic = hasMagic || sp[1]
  }

  // handle the case where we had a +( thing at the *end*
  // of the pattern.
  // each pattern list stack adds 3 chars, and we need to go through
  // and escape any | chars that were passed through as-is for the regexp.
  // Go through and escape them, taking care not to double-escape any
  // | chars that were already escaped.
  for (var pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
    var tail = re.slice(pl.reStart + 3)
    // maybe some even number of \, then maybe 1 \, followed by a |
    tail = tail.replace(/((?:\\{2})*)(\\?)\|/g, function (_, $1, $2) {
      if (!$2) {
        // the | isn't already escaped, so escape it.
        $2 = '\\'
      }

      // need to escape all those slashes *again*, without escaping the
      // one that we need for escaping the | character.  As it works out,
      // escaping an even number of slashes can be done by simply repeating
      // it exactly after itself.  That's why this trick works.
      //
      // I am sorry that you have to see this.
      return $1 + $1 + $2 + '|'
    })

    this.debug('tail=%j\n   %s', tail, tail)
    var t = pl.type === '*' ? star
      : pl.type === '?' ? qmark
      : '\\' + pl.type

    hasMagic = true
    re = re.slice(0, pl.reStart) + t + '\\(' + tail
  }

  // handle trailing things that only matter at the very end.
  clearStateChar()
  if (escaping) {
    // trailing \\
    re += '\\\\'
  }

  // only need to apply the nodot start if the re starts with
  // something that could conceivably capture a dot
  var addPatternStart = false
  switch (re.charAt(0)) {
    case '.':
    case '[':
    case '(': addPatternStart = true
  }

  // if the re is not "" at this point, then we need to make sure
  // it doesn't match against an empty path part.
  // Otherwise a/* will match a/, which it should not.
  if (re !== '' && hasMagic) re = '(?=.)' + re

  if (addPatternStart) re = patternStart + re

  // parsing just a piece of a larger pattern.
  if (isSub === SUBPARSE) {
    return [re, hasMagic]
  }

  // skip the regexp for non-magical patterns
  // unescape anything in it, though, so that it'll be
  // an exact match against a file etc.
  if (!hasMagic) {
    return globUnescape(pattern)
  }

  var flags = options.nocase ? 'i' : ''
  var regExp = new RegExp('^' + re + '$', flags)

  regExp._glob = pattern
  regExp._src = re

  return regExp
}

minimatch.makeRe = function (pattern, options) {
  return new Minimatch(pattern, options || {}).makeRe()
}

Minimatch.prototype.makeRe = makeRe
function makeRe () {
  if (this.regexp || this.regexp === false) return this.regexp

  // at this point, this.set is a 2d array of partial
  // pattern strings, or "**".
  //
  // It's better to use .match().  This function shouldn't
  // be used, really, but it's pretty convenient sometimes,
  // when you just want to work with a regex.
  var set = this.set

  if (!set.length) {
    this.regexp = false
    return this.regexp
  }
  var options = this.options

  var twoStar = options.noglobstar ? star
    : options.dot ? twoStarDot
    : twoStarNoDot
  var flags = options.nocase ? 'i' : ''

  var re = set.map(function (pattern) {
    return pattern.map(function (p) {
      return (p === GLOBSTAR) ? twoStar
      : (typeof p === 'string') ? regExpEscape(p)
      : p._src
    }).join('\\\/')
  }).join('|')

  // must match entire pattern
  // ending in a * or ** will make it less strict.
  re = '^(?:' + re + ')$'

  // can match anything, as long as it's not this.
  if (this.negate) re = '^(?!' + re + ').*$'

  try {
    this.regexp = new RegExp(re, flags)
  } catch (ex) {
    this.regexp = false
  }
  return this.regexp
}

minimatch.match = function (list, pattern, options) {
  options = options || {}
  var mm = new Minimatch(pattern, options)
  list = list.filter(function (f) {
    return mm.match(f)
  })
  if (mm.options.nonull && !list.length) {
    list.push(pattern)
  }
  return list
}

Minimatch.prototype.match = match
function match (f, partial) {
  this.debug('match', f, this.pattern)
  // short-circuit in the case of busted things.
  // comments, etc.
  if (this.comment) return false
  if (this.empty) return f === ''

  if (f === '/' && partial) return true

  var options = this.options

  // windows: need to use /, not \
  if (path.sep !== '/') {
    f = f.split(path.sep).join('/')
  }

  // treat the test path as a set of pathparts.
  f = f.split(slashSplit)
  this.debug(this.pattern, 'split', f)

  // just ONE of the pattern sets in this.set needs to match
  // in order for it to be valid.  If negating, then just one
  // match means that we have failed.
  // Either way, return on the first hit.

  var set = this.set
  this.debug(this.pattern, 'set', set)

  // Find the basename of the path by looking for the last non-empty segment
  var filename
  var i
  for (i = f.length - 1; i >= 0; i--) {
    filename = f[i]
    if (filename) break
  }

  for (i = 0; i < set.length; i++) {
    var pattern = set[i]
    var file = f
    if (options.matchBase && pattern.length === 1) {
      file = [filename]
    }
    var hit = this.matchOne(file, pattern, partial)
    if (hit) {
      if (options.flipNegate) return true
      return !this.negate
    }
  }

  // didn't get any hits.  this is success if it's a negative
  // pattern, failure otherwise.
  if (options.flipNegate) return false
  return this.negate
}

// set partial to true to test if, for example,
// "/a/b" matches the start of "/*/b/*/d"
// Partial means, if you run out of file before you run
// out of pattern, then that's fine, as long as all
// the parts match.
Minimatch.prototype.matchOne = function (file, pattern, partial) {
  var options = this.options

  this.debug('matchOne',
    { 'this': this, file: file, pattern: pattern })

  this.debug('matchOne', file.length, pattern.length)

  for (var fi = 0,
      pi = 0,
      fl = file.length,
      pl = pattern.length
      ; (fi < fl) && (pi < pl)
      ; fi++, pi++) {
    this.debug('matchOne loop')
    var p = pattern[pi]
    var f = file[fi]

    this.debug(pattern, p, f)

    // should be impossible.
    // some invalid regexp stuff in the set.
    if (p === false) return false

    if (p === GLOBSTAR) {
      this.debug('GLOBSTAR', [pattern, p, f])

      // "**"
      // a/**/b/**/c would match the following:
      // a/b/x/y/z/c
      // a/x/y/z/b/c
      // a/b/x/b/x/c
      // a/b/c
      // To do this, take the rest of the pattern after
      // the **, and see if it would match the file remainder.
      // If so, return success.
      // If not, the ** "swallows" a segment, and try again.
      // This is recursively awful.
      //
      // a/**/b/**/c matching a/b/x/y/z/c
      // - a matches a
      // - doublestar
      //   - matchOne(b/x/y/z/c, b/**/c)
      //     - b matches b
      //     - doublestar
      //       - matchOne(x/y/z/c, c) -> no
      //       - matchOne(y/z/c, c) -> no
      //       - matchOne(z/c, c) -> no
      //       - matchOne(c, c) yes, hit
      var fr = fi
      var pr = pi + 1
      if (pr === pl) {
        this.debug('** at the end')
        // a ** at the end will just swallow the rest.
        // We have found a match.
        // however, it will not swallow /.x, unless
        // options.dot is set.
        // . and .. are *never* matched by **, for explosively
        // exponential reasons.
        for (; fi < fl; fi++) {
          if (file[fi] === '.' || file[fi] === '..' ||
            (!options.dot && file[fi].charAt(0) === '.')) return false
        }
        return true
      }

      // ok, let's see if we can swallow whatever we can.
      while (fr < fl) {
        var swallowee = file[fr]

        this.debug('\nglobstar while', file, fr, pattern, pr, swallowee)

        // XXX remove this slice.  Just pass the start index.
        if (this.matchOne(file.slice(fr), pattern.slice(pr), partial)) {
          this.debug('globstar found match!', fr, fl, swallowee)
          // found a match.
          return true
        } else {
          // can't swallow "." or ".." ever.
          // can only swallow ".foo" when explicitly asked.
          if (swallowee === '.' || swallowee === '..' ||
            (!options.dot && swallowee.charAt(0) === '.')) {
            this.debug('dot detected!', file, fr, pattern, pr)
            break
          }

          // ** swallows a segment, and continue.
          this.debug('globstar swallow a segment, and continue')
          fr++
        }
      }

      // no match was found.
      // However, in partial mode, we can't say this is necessarily over.
      // If there's more *pattern* left, then
      if (partial) {
        // ran out of file
        this.debug('\n>>> no match, partial?', file, fr, pattern, pr)
        if (fr === fl) return true
      }
      return false
    }

    // something other than **
    // non-magic patterns just have to match exactly
    // patterns with magic have been turned into regexps.
    var hit
    if (typeof p === 'string') {
      if (options.nocase) {
        hit = f.toLowerCase() === p.toLowerCase()
      } else {
        hit = f === p
      }
      this.debug('string match', p, f, hit)
    } else {
      hit = f.match(p)
      this.debug('pattern match', p, f, hit)
    }

    if (!hit) return false
  }

  // Note: ending in / means that we'll get a final ""
  // at the end of the pattern.  This can only match a
  // corresponding "" at the end of the file.
  // If the file ends in /, then it can only match a
  // a pattern that ends in /, unless the pattern just
  // doesn't have any more for it. But, a/b/ should *not*
  // match "a/b/*", even though "" matches against the
  // [^/]*? pattern, except in partial mode, where it might
  // simply not be reached yet.
  // However, a/b/ should still satisfy a/*

  // now either we fell off the end of the pattern, or we're done.
  if (fi === fl && pi === pl) {
    // ran out of pattern and filename at the same time.
    // an exact hit!
    return true
  } else if (fi === fl) {
    // ran out of file, but still had pattern left.
    // this is ok if we're doing the match as part of
    // a glob fs traversal.
    return partial
  } else if (pi === pl) {
    // ran out of pattern, still have file left.
    // this is only acceptable if we're on the very last
    // empty segment of a file with a trailing slash.
    // a/* should match a/b/
    var emptyFileEnd = (fi === fl - 1) && (file[fi] === '')
    return emptyFileEnd
  }

  // should be unreachable.
  throw new Error('wtf?')
}

// replace stuff like \* with *
function globUnescape (s) {
  return s.replace(/\\(.)/g, '$1')
}

function regExpEscape (s) {
  return s.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&')
}

},{"brace-expansion":3,"path":1}],3:[function(require,module,exports){
var concatMap = require('concat-map');
var balanced = require('balanced-match');

module.exports = expandTop;

var escSlash = '\0SLASH'+Math.random()+'\0';
var escOpen = '\0OPEN'+Math.random()+'\0';
var escClose = '\0CLOSE'+Math.random()+'\0';
var escComma = '\0COMMA'+Math.random()+'\0';
var escPeriod = '\0PERIOD'+Math.random()+'\0';

function numeric(str) {
  return parseInt(str, 10) == str
    ? parseInt(str, 10)
    : str.charCodeAt(0);
}

function escapeBraces(str) {
  return str.split('\\\\').join(escSlash)
            .split('\\{').join(escOpen)
            .split('\\}').join(escClose)
            .split('\\,').join(escComma)
            .split('\\.').join(escPeriod);
}

function unescapeBraces(str) {
  return str.split(escSlash).join('\\')
            .split(escOpen).join('{')
            .split(escClose).join('}')
            .split(escComma).join(',')
            .split(escPeriod).join('.');
}


// Basically just str.split(","), but handling cases
// where we have nested braced sections, which should be
// treated as individual members, like {a,{b,c},d}
function parseCommaParts(str) {
  if (!str)
    return [''];

  var parts = [];
  var m = balanced('{', '}', str);

  if (!m)
    return str.split(',');

  var pre = m.pre;
  var body = m.body;
  var post = m.post;
  var p = pre.split(',');

  p[p.length-1] += '{' + body + '}';
  var postParts = parseCommaParts(post);
  if (post.length) {
    p[p.length-1] += postParts.shift();
    p.push.apply(p, postParts);
  }

  parts.push.apply(parts, p);

  return parts;
}

function expandTop(str) {
  if (!str)
    return [];

  return expand(escapeBraces(str), true).map(unescapeBraces);
}

function identity(e) {
  return e;
}

function embrace(str) {
  return '{' + str + '}';
}
function isPadded(el) {
  return /^-?0\d/.test(el);
}

function lte(i, y) {
  return i <= y;
}
function gte(i, y) {
  return i >= y;
}

function expand(str, isTop) {
  var expansions = [];

  var m = balanced('{', '}', str);
  if (!m || /\$$/.test(m.pre)) return [str];

  var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m.body);
  var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m.body);
  var isSequence = isNumericSequence || isAlphaSequence;
  var isOptions = /^(.*,)+(.+)?$/.test(m.body);
  if (!isSequence && !isOptions) {
    // {a},b}
    if (m.post.match(/,.*}/)) {
      str = m.pre + '{' + m.body + escClose + m.post;
      return expand(str);
    }
    return [str];
  }

  var n;
  if (isSequence) {
    n = m.body.split(/\.\./);
  } else {
    n = parseCommaParts(m.body);
    if (n.length === 1) {
      // x{{a,b}}y ==> x{a}y x{b}y
      n = expand(n[0], false).map(embrace);
      if (n.length === 1) {
        var post = m.post.length
          ? expand(m.post, false)
          : [''];
        return post.map(function(p) {
          return m.pre + n[0] + p;
        });
      }
    }
  }

  // at this point, n is the parts, and we know it's not a comma set
  // with a single entry.

  // no need to expand pre, since it is guaranteed to be free of brace-sets
  var pre = m.pre;
  var post = m.post.length
    ? expand(m.post, false)
    : [''];

  var N;

  if (isSequence) {
    var x = numeric(n[0]);
    var y = numeric(n[1]);
    var width = Math.max(n[0].length, n[1].length)
    var incr = n.length == 3
      ? Math.abs(numeric(n[2]))
      : 1;
    var test = lte;
    var reverse = y < x;
    if (reverse) {
      incr *= -1;
      test = gte;
    }
    var pad = n.some(isPadded);

    N = [];

    for (var i = x; test(i, y); i += incr) {
      var c;
      if (isAlphaSequence) {
        c = String.fromCharCode(i);
        if (c === '\\')
          c = '';
      } else {
        c = String(i);
        if (pad) {
          var need = width - c.length;
          if (need > 0) {
            var z = new Array(need + 1).join('0');
            if (i < 0)
              c = '-' + z + c.slice(1);
            else
              c = z + c;
          }
        }
      }
      N.push(c);
    }
  } else {
    N = concatMap(n, function(el) { return expand(el, false) });
  }

  for (var j = 0; j < N.length; j++) {
    for (var k = 0; k < post.length; k++) {
      var expansion = pre + N[j] + post[k];
      if (!isTop || isSequence || expansion)
        expansions.push(expansion);
    }
  }

  return expansions;
}


},{"balanced-match":4,"concat-map":5}],4:[function(require,module,exports){
module.exports = balanced;
function balanced(a, b, str) {
  var bal = 0;
  var m = {};
  var ended = false;

  for (var i = 0; i < str.length; i++) {
    if (a == str.substr(i, a.length)) {
      if (!('start' in m)) m.start = i;
      bal++;
    }
    else if (b == str.substr(i, b.length) && 'start' in m) {
      ended = true;
      bal--;
      if (!bal) {
        m.end = i;
        m.pre = str.substr(0, m.start);
        m.body = (m.end - m.start > 1)
          ? str.substring(m.start + a.length, m.end)
          : '';
        m.post = str.slice(m.end + b.length);
        return m;
      }
    }
  }

  // if we opened more than we closed, find the one we closed
  if (bal && ended) {
    var start = m.start + a.length;
    m = balanced(a, b, str.substr(start));
    if (m) {
      m.start += start;
      m.end += start;
      m.pre = str.slice(0, start) + m.pre;
    }
    return m;
  }
}

},{}],5:[function(require,module,exports){
module.exports = function (xs, fn) {
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        var x = fn(xs[i], i);
        if (isArray(x)) res.push.apply(res, x);
        else res.push(x);
    }
    return res;
};

var isArray = Array.isArray || function (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],6:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

(function() {
  "use strict";

  var Promise = require("./promise"),
      async   = require("./async");

  function _result(input, args, context) {
    if (typeof(input) === "function") {
      return input.apply(context, args||[]);
    }
    return input;
  }

  function All(values) {
    values = values || [];

    // The input is the queue of items that need to be resolved.
    var resolutions = [],
        promise     = Promise.defer(),
        context     = this,
        remaining   = values.length;

    if (!values.length) {
      return promise.resolve(values);
    }

    // Check everytime a new resolved promise occurs if we are done processing all
    // the dependent promises.  If they are all done, then resolve the when promise
    function checkPending() {
      remaining--;
      if (!remaining) {
        promise.resolve.call(context, resolutions);
      }
    }

    // Wrap the resolution to keep track of the proper index in the closure
    function resolve(index) {
      return function() {
        resolutions[index] = arguments.length === 1 ? arguments[0] : arguments;
        checkPending();
      };
    }

    function processQueue() {
      var i, item, length;
      for (i = 0, length = remaining; i < length; i++) {
        item = values[i];
        if (item && typeof item.then === "function") {
          item.then(resolve(i), promise.reject);
        }
        else {
          resolutions[i] = _result(item);
          checkPending();
        }
      }
    }

    // Process the promises and callbacks
    async(processQueue);
    return promise;
  }

  module.exports = All;
}());


},{"./async":7,"./promise":8}],7:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

/*global process, setImmediate*/
(function() {
  "use strict";

  var nextTick;

  function Async(cb) {
    nextTick(cb);
  }

  Async.delay = function(callback, timeout, args) {
    setTimeout(callback.apply.bind(callback, this, args || []), timeout);
  };


  /**
   * Find the prefered method for queue callbacks in the event loop
   */

  if (typeof(process) === "object" && typeof(process.nextTick) === "function") {
    nextTick = process.nextTick;
  }
  else if (typeof(setImmediate) === "function") {
    nextTick = setImmediate;
  }
  else {
    nextTick = function(cb) {
      setTimeout(cb, 0);
    };
  }

  Async.nextTick = nextTick;
  module.exports = Async;
}());

},{}],8:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

(function() {
  "use strict";

  var async = require("./async");

  var states = {
    "pending"  : 0,
    "resolved" : 1,
    "rejected" : 2,
    "always"   : 3,
    "notify"   : 4
  };

  var strStates = [
    "pending",
    "resolved",
    "rejected"
  ];

  /**
   * Small Promise
   */
  function Promise(resolver, stateManager) {
    stateManager = stateManager || new StateManager();
    var target = this;

    target.then = function(onResolved, onRejected) {
      return stateManager.then(onResolved, onRejected);
    };

    target.resolve = function() {
      stateManager.transition(states.resolved, arguments, this);
      return target;
    };

    target.reject = function() {
      stateManager.transition(states.rejected, arguments, this);
      return target;
    };

    // Read only access point for the promise.
    target.promise = {
      then   : target.then,
      always : target.always,
      done   : target.done,
      catch  : target.fail,
      fail   : target.fail,
      notify : target.notify,
      state  : target.state,
      constructor : Promise // Helper to detect spromise instances
    };

    target.promise.promise = target.promise;
    target.then.stateManager = stateManager;

    if (resolver) {
      resolver.call(target, target.resolve, target.reject);
    }
  }

  Promise.prototype.done = function(cb) {
    this.then.stateManager.enqueue(states.resolved, cb);
    return this.promise;
  };

  Promise.prototype.catch = Promise.prototype.fail = function(cb) {
    this.then.stateManager.enqueue(states.rejected, cb);
    return this.promise;
  };

  Promise.prototype.finally = Promise.prototype.always = function(cb) {
    this.then.stateManager.enqueue(states.always, cb);
    return this.promise;
  };

  Promise.prototype.notify = function(cb) {
    this.then.stateManager.enqueue(states.notify, cb);
    return this.promise;
  };

  Promise.prototype.state = function() {
    return strStates[this.then.stateManager.state];
  };

  Promise.prototype.isPending = function() {
    return this.then.stateManager.state === states.pending;
  };

  Promise.prototype.isResolved = function() {
    return this.then.stateManager.state === states.resolved;
  };

  Promise.prototype.isRejected = function() {
    return this.then.stateManager.state === states.resolved;
  };

  Promise.prototype.delay = function delay(ms) {
    var _self = this;
    return new Promise(function(resolve, reject) {
      _self.then(function() {
        async.delay(resolve.bind(this), ms, arguments);
      }, reject.bind(this));
    });
  };

  /**
   * Provides a set of interfaces to manage callback queues and the resolution state
   * of the promises.
   */
  function StateManager(options) {
    // Initial state is pending
    this.state = states.pending;

    // If a state is passed in, then we go ahead and initialize the state manager with it
    if (options && options.state) {
      this.transition(options.state, options.value, options.context);
    }
  }

  /**
   * Figure out if the promise is pending/resolved/rejected and do the appropriate
   * action with the callback based on that.
   */
  StateManager.prototype.enqueue = function (state, cb) {
    if (!this.state) {
      (this.queue || (this.queue = [])).push(TaskAction);
    }
    else {
      // If the promise has already been resolved and its queue has been processed, then
      // we need to schedule the new task for processing ASAP by putting in the asyncQueue
      TaskManager.asyncTask(TaskAction);
    }

    var stateManager = this;
    function TaskAction() {
      if (stateManager.state === state || states.always === state) {
        cb.apply(stateManager.context, stateManager.value);
      }
      else if (states.notify === state) {
        cb.call(stateManager.context, stateManager.state, stateManager.value);
      }
    }
  };

  /**
   * Transitions the state of the promise from pending to either resolved or
   * rejected.  If the promise has already been resolved or rejected, then
   * this is a noop.
   */
  StateManager.prototype.transition = function (state, value, context) {
    if (this.state) {
      return;
    }

    this.state   = state;
    this.context = context;
    this.value   = value;

    var queue = this.queue;
    if (queue) {
      this.queue = null;
      TaskManager.asyncQueue(queue);
    }
  };

  // 2.2.7: https://promisesaplus.com/#point-40
  StateManager.prototype.then = function(onResolved, onRejected) {
    var stateManager = this;

    // Make sure onResolved and onRejected are functions, or null otherwise
    onResolved = (onResolved && typeof(onResolved) === "function") ? onResolved : null;
    onRejected = (onRejected && typeof(onRejected) === "function") ? onRejected : null;

    // 2.2.7.3 and 2.2.7.4: https://promisesaplus.com/#point-43
    // If there are no onResolved or onRejected callbacks and the promise
    // is already resolved, we just return a new promise and copy the state
    if ((!onResolved && stateManager.state === states.resolved) ||
        (!onRejected && stateManager.state === states.rejected)) {
      return new Promise(null, stateManager);
    }

    var promise = new Promise();
    stateManager.enqueue(states.notify, function NotifyAction(state, value) {
      var handler = (state === states.resolved) ? (onResolved || onRejected) : (onRejected || onResolved);
      if (handler) {
        value = StateManager.runHandler(state, value, this, promise, handler);
      }

      if (value !== false) {
        (new Resolution({promise: promise})).finalize(state, value, this);
      }
    });
    return promise;
  };


  StateManager.runHandler = function(state, value, context, promise, handler) {
    // Try catch in case calling the handler throws an exception
    try {
      value = handler.apply(context, value);
    }
    catch(ex) {
      printDebug(ex);
      promise.reject.call(context, ex);
      return false;
    }

    return value === undefined ? [] : [value];
  };


  /**
   * Thenable resolution
   */
  function Resolution(options) {
    this.promise = options.promise;
  }

  /**
   * Promise resolution procedure
   *
   * @param {states} state - Is the state of the promise resolution (resolved/rejected)
   * @param {array} value - Is value of the resolved promise
   * @param {context} context - Is that context used when calling resolved/rejected
   */
  Resolution.prototype.finalize = function(state, value, context) {
    var resolution = this,
        promise    = this.promise,
        input, pending;

    if (value.length) {
      input = value[0];

      // 2.3.1 https://promisesaplus.com/#point-48
      if (input === promise) {
        pending = promise.reject.call(context, new TypeError("Resolution input must not be the promise being resolved"));
      }

      // 2.3.2 https://promisesaplus.com/#point-49
      // if the incoming promise is an instance of spromise, we adopt its state
      else if (input && input.constructor === Promise) {
        pending = input.notify(function NotifyDelegate(state, value) {
          resolution.finalize(state, value, this);
        });
      }

      // 2.3.3 https://promisesaplus.com/#point-53
      // Otherwise, if x is an object or function
      else if (input !== undefined && input !== null) {
        switch(typeof(input)) {
          case "object":
          case "function":
            pending = this.runThenable(input, context);
        }
      }
    }

    // 2.3.4 https://promisesaplus.com/#point-64
    // If x is not an object or function, fulfill promise with x.
    if (!pending) {
      if (state === states.resolved) {
        promise.resolve.apply(context, value);
      }
      else {
        promise.reject.apply(context, value);
      }
    }
  };

  /**
   * Run thenable.
   */
  Resolution.prototype.runThenable = function(thenable, context) {
    var resolution = this,
        resolved   = false;

    try {
      // 2.3.3.1 https://promisesaplus.com/#point-54
      var then = thenable.then;  // Reading `.then` could throw
      if (typeof(then) === "function") {
        // 2.3.3.3 https://promisesaplus.com/#point-56
        then.call(thenable, function resolvePromise() {
          if (!resolved) { resolved = true;
            resolution.finalize(states.resolved, arguments, this);
          }
        }, function rejectPromise() {
          if (!resolved) { resolved = true;
            resolution.promise.reject.apply(this, arguments);
          }
        });

        return true;
      }
    }
    catch (ex) {
      if (!resolved) {
        resolution.promise.reject.call(context, ex);
      }

      return true;
    }

    return false;
  };

  /**
   * Task manager to handle queuing up async tasks in an optimal manner
   */
  var TaskManager = {
    _asyncQueue: [],
    asyncTask: function(task) {
      if (TaskManager._asyncQueue.push(task) === 1) {
        async(TaskManager.taskRunner(TaskManager._asyncQueue));
      }
    },
    asyncQueue: function(queue) {
      if (queue.length === 1) {
        TaskManager.asyncTask(queue[0]);
      }
      else {
        TaskManager.asyncTask(TaskManager.taskRunner(queue));
      }
    },
    taskRunner: function(queue) {
      return function runTasks() {
        var task;
        while ((task = queue[0])) {
          TaskManager._runTask(task);
          queue.shift();
        }
      };
    },
    _runTask: function(task) {
      try {
        task();
      }
      catch(ex) {
        printDebug(ex);
      }
    }
  };

  function printDebug(ex) {
    if (Factory.debug) {
      console.error(ex);
      if (ex && ex.stack) {
        console.log(ex.stack);
      }
    }
  }

  /**
   * Public interface to create promises
   */
  function Factory(resolver) {
    return new Promise(resolver);
  }

  // Enable type check with instanceof
  Factory.prototype = Promise.prototype;

  /**
   * Interface to play nice with libraries like when and q.
   */
  Factory.defer = function () {
    return new Promise();
  };

  /**
   * Create a promise that's already rejected
   *
   * @returns {Promise} A promise that is alraedy rejected with the input value
   */
  Factory.reject = function () {
    return new Promise(null, new StateManager({
      context: this,
      value: arguments,
      state: states.rejected
    }));
  };

  /**
   * Interface that makes sure a promise is returned, regardless of the input.
   * 1. If the input is a promsie, then that's immediately returned.
   * 2. If the input is a thenable (has a then method), then a new promise is returned
   *    that's chained to the input thenable.
   * 3. If the input is any other value, then a new promise is returned and resolved with
   *    the input value
   *
   * @returns {Promise}
   */
  Factory.resolve = Factory.thenable = function (value) {
    if (value) {
      if (value.constructor === Promise) {
        return value;
      }
      else if (typeof(value.then) === "function") {
        return new Promise(value.then);
      }
    }

    return new Promise(null, new StateManager({
      context: this,
      value: arguments,
      state: states.resolved
    }));
  };

  /**
   * Creates a promise that's resolved after ms number of milleseconds. All arguments passed
   * in to delay, with the excpetion of ms, will be used to resolve the new promise with.
   *
   * @param {number} ms - Number of milliseconds to wait before the promise is resolved.
   */
  Factory.delay = function delay(ms) {
    var args = Array.prototype.slice(arguments, 1);
    return new Promise(function(resolve) {
      async.delay(resolve.bind(this), ms, args);
    });
  };

  // Expose enums for the states
  Factory.states = states;
  Factory.debug  = false;
  module.exports = Factory;
}());

},{"./async":7}],9:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

(function() {
  "use strict";

  var Promise = require("./promise");

  function Race(iterable) {
    if (!iterable) {
      return Promise.resolve();
    }

    return new Promise(function(resolve, reject) {
      var i, length, _done = false;
      for (i = 0, length = iterable.length; i < length; i++) {
        iterable[i].then(_resolve, _reject);
      }

      function _resolve() {
        if (!_done) {
          _done = true;
          /*jshint -W040 */
          resolve.apply(this, arguments);
          /*jshint +W040 */
        }
      }

      function _reject() {
        if (!_done) {
          _done = true;
          /*jshint -W040 */
          reject.apply(this, arguments);
          /*jshint +W040 */
        }
      }
    });
  }

  module.exports = Race;
}());

},{"./promise":8}],10:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

(function() {
  "use strict";

  var Promise   = require("./promise");
  Promise.async = require("./async");
  Promise.when  = require("./when");
  Promise.all   = require("./all");
  Promise.race  = require("./race");

  module.exports = Promise;
}());

},{"./all":6,"./async":7,"./promise":8,"./race":9,"./when":11}],11:[function(require,module,exports){
/**
 * spromise Copyright (c) 2014 Miguel Castillo.
 * Licensed under MIT
 */

(function() {
  "use strict";

  var Promise = require("./promise"),
      All     = require("./all");

  /**
   * Interface to allow multiple promises to be synchronized
   */
  function When() {
    var context = this, args = arguments;
    return new Promise(function(resolve, reject) {
      All.call(context, args).then(function(results) {
        resolve.apply(context, results);
      },
      function(reason) {
        reject.call(context, reason);
      });
    });
  }

  module.exports = When;
}());

},{"./all":6,"./promise":8}],12:[function(require,module,exports){
(function () {
  "use strict";

  var Promise     = require('promise'),
      Logger      = require('logger'),
      Utils       = require('./utils'),
      Fetcher     = require('./interfaces/fetcher'),
      Compiler    = require('./interfaces/compiler'),
      Resolver    = require('./interfaces/resolver'),
      Import      = require('./import'),
      Loader      = require('./loader'),
      Module      = require('./module'),
      Plugin      = require('./plugin'),
      Registry    = require('./registry'),
      RuleMatcher = require('./rule-matcher'),
      Middleware  = require('./middleware');

  var getRegistryId = Registry.idGenerator('bitloader');

  var ModuleState = {
    LOADED: "loaded"
  };


  /**
   * @class
   *
   * Facade for relevant interfaces to register and import modules
   */
  function Bitloader(options, factories) {
    options   = options   || {};
    factories = factories || {};

    this.settings = options;
    this.context  = Registry.getById(getRegistryId());

    this.plugins = {};

    this.rules = {
      ignore: new RuleMatcher()
    };

    this.pipelines = {
      transform  : new Middleware(this),
      dependency : new Middleware(this)
    };

    // Override any of these factories if you need specialized implementation
    this.providers = {
      resolver : factories.resolver ? factories.resolver(this) : new Bitloader.Resolver(this),
      fetcher  : factories.fetcher  ? factories.fetcher(this)  : new Bitloader.Fetcher(this),
      loader   : factories.loader   ? factories.loader(this)   : new Bitloader.Loader(this),
      importer : factories.import   ? factories.import(this)   : new Bitloader.Import(this),
      compiler : factories.compiler ? factories.compiler(this) : new Bitloader.Compiler(this)
    };

    // Public Interface
    var providers = this.providers;
    this.resolve  = providers.resolver.resolve.bind(providers.resolver);
    this.fetch    = providers.fetcher.fetch.bind(providers.fetcher);
    this.load     = providers.loader.load.bind(providers.loader);
    this.register = providers.loader.register.bind(providers.loader);
    this.import   = providers.importer.import.bind(providers.importer);
    this.compile  = providers.compiler.compile.bind(providers.compiler);

    // Register pipeline options.
    for (var pipeline in options) {
      if (options.hasOwnProperty(pipeline) && this.pipelines.hasOwnProperty(pipeline)) {
        this.pipelines[pipeline].use(options[pipeline]);
      }
    }
  }


  /**
   * Method to read files from storage. This is to be implemented by the code
   * making use of Bitloader.
   *
   * @param {string} name - Name of the module whose file content needs to be
   *  fetched.
   * @param {object} parentMeta - Parent module meta object fetching a
   *  dependency.
   *
   * @returns {Promise} Promise that when resolved, a module meta object
   *  with a "source" property is returned. The "source" property is where
   *  the content of the file is stored.
   */
  Bitloader.prototype.fetch = function(){};


  /**
   * Method for asynchronously loading modules.
   *
   * @returns {Pormise} That when resolved, it returns the full instance of the
   *  module loaded
   */
  Bitloader.prototype.load = function(){};


  /**
   * Method to asynchronously load modules
   *
   * @function
   *
   * @param {string|Array.<string>} names - Module or list of modules names to
   *  load. These names map back to the paths settings Bitloader was created
   *  with.
   *
   * @returns {Promise} That when resolved, all the imported modules are passed
   *  back as arguments.
   */
  Bitloader.prototype.import = function(){};


  /**
   * Method to define a module to be asynchronously loaded via the
   * [import]{@link Bitloader#import} method
   *
   * @param {string} name - Name of the module to register
   * @param {Array.<string>} deps - Collection of dependencies to be loaded and
   *  passed into the factory callback method.
   * @param {Function} factory - Function to be called in order to instantiate
   *  (realize) the module
   */
  Bitloader.prototype.register = function(){};


  /**
   * Clears the context, which means that all cached modules and other pertinent data
   * will be deleted.
   */
  Bitloader.prototype.clear = function() {
    this.context.clear();
  };


  /**
   * Checks if the module instance is in the module registry
   */
  Bitloader.prototype.hasModule = function(name) {
    return this.context.hasModule(name) || this.providers.loader.isLoaded(name);
  };


  /**
   * Returns the module instance if one exists.  If the module instance isn't in the
   * module registry, then a TypeError exception is thrown
   */
  Bitloader.prototype.getModule = function(name) {
    if (!this.hasModule(name)) {
      throw new TypeError("Module `" + name + "` has not yet been loaded");
    }

    if (!this.context.hasModule(name)) {
      return this.context.setModule(ModuleState.LOADED, name, this.providers.loader.syncBuild(name));
    }

    return this.context.getModule(name);
  };


  /**
   * Add a module instance to the module registry.  And if the module already exists in
   * the module registry, then a TypeError exception is thrown.
   *
   * @param {Module} mod - Module instance to add to the module registry
   *
   * @returns {Module} Module instance added to the registry
   */
  Bitloader.prototype.setModule = function(mod) {
    var name = mod.name;

    if (!(mod instanceof(Module))) {
      throw new TypeError("Module `" + name + "` is not an instance of Module");
    }

    if (!name || typeof(name) !== 'string') {
      throw new TypeError("Module must have a name");
    }

    if (this.context.hasModule(name)) {
      throw new TypeError("Module instance `" + name + "` already exists");
    }

    return this.context.setModule(ModuleState.LOADED, name, mod);
  };


  /**
   * Interface to delete a module from the registry.
   *
   * @param {string} name - Name of the module to delete
   *
   * @returns {Module} Deleted module
   */
  Bitloader.prototype.deleteModule = function(name) {
    if (!this.context.hasModule(name)) {
      throw new TypeError("Module instance `" + name + "` does not exists");
    }

    return this.context.deleteModule(name);
  };


  /**
   * Returns the module code from the module registry. If the module code has not
   * yet been fully compiled, then we defer to the loader to build the module and
   * return the code.
   *
   * @param {string} name - The name of the module code to get from the module registry
   *
   * @return {object} The module code.
   */
  Bitloader.prototype.getModuleCode = function(name) {
    if (!this.hasModule(name)) {
      throw new TypeError("Module `" + name + "` has not yet been loaded");
    }

    return this.getModule(name).code;
  };


  /**
   * Sets module evaluated code directly in the module registry.
   *
   * @param {string} name - The name of the module, which is used by other modules
   *  that need it as a dependency.
   * @param {object} code - The evaluated code to be set
   *
   * @returns {object} The evaluated code.
   */
  Bitloader.prototype.setModuleCode = function(name, code) {
    if (this.hasModule(name)) {
      throw new TypeError("Module code for `" + name + "` already exists");
    }

    var mod = new Module({
      name: name,
      code: code
    });

    return this.setModule(mod).code;
  };


  /**
   * Checks is the module has been fully finalized, which is when the module instance
   * get stored in the module registry
   */
  Bitloader.prototype.isModuleCached = function(name) {
    return this.context.hasModule(name);
  };


  /**
   * Add ignore rules for configuring what the different pipelines shoud not process.
   *
   * @param {Object} rule - Rule configuration
   * @returns {Bitloader} Bitloader instance
   */
  Bitloader.prototype.ignore = function(rule) {
    if (!rule) {
      throw new TypeError("Must provide a rule configuration");
    }

    var i, length, ruleNames;
    if (!rule.name) {
      ruleNames = ["transform", "dependency"];
    }
    else {
      ruleNames = Utils.isArray(rule.name) ? rule.name : [rule.name];
    }

    for (i = 0, length = ruleNames.length; i < length; i++) {
      this.rules.ignore.add({
        name: ruleNames[i],
        match: rule.match
      });
    }

    return this;
  };


  /**
   * Registers plugins into the pipeline.
   *
   * @param {string} name - Name of the plugin
   * @param {object} options - Object whose keys are the name of the particular
   *  pipeline they intend to register with. For example, if the plugin is to
   *  register a `transform` and a `dependency` pipeline handler, then the
   *  plugin object will have entries with those names. E.g.
   *
   *  ``` javascript
   *  var pluginDefinition = {
   *    "transform": function(meta) {
   *      console.log(meta);
   *    },
   *    "dependency": function(meta) {
   *      console.log(meta);
   *    }
   *  };
   *
   *  bitlaoder.plugin(plugin);
   *  ```
   */
  Bitloader.prototype.plugin = function(name, options) {
    if (Utils.isPlainObject(name)) {
      options = name;
      name = null;
    }

    var plugin;

    // If plugin exists, then we get it so that we can update it with the new settings.
    // Otherwise we create a new plugin and configure it with the incoming settings.
    if (this.plugins.hasOwnProperty(name)) {
      plugin = this.plugins[name];
    }
    else {
      plugin = new Plugin(name, this);
      this.plugins[plugin.name] = plugin;
    }

    return plugin.configure(options);
  };


  /**
   * Method to check if a plugin already exists.
   */
  Bitloader.prototype.hasPlugin = function(name) {
    return this.plugins.hasOwnProperty(name);
  };


  /**
   * Method to get a plugin that has already been loaded.
   */
  Bitloader.prototype.getPlugin = function(name) {
    if (this.plugins.hasOwnProperty(name)) {
      throw new TypeError("Plugin '" + name + "' not found");
    }

    return this.plugins[name];
  };


  Bitloader.prototype.Promise    = Promise;
  Bitloader.prototype.Module     = Module;
  Bitloader.prototype.Utils      = Utils;
  Bitloader.prototype.Logger     = Logger;
  Bitloader.prototype.Middleware = Middleware;

  // Expose constructors and utilities
  Bitloader.Promise     = Promise;
  Bitloader.Utils       = Utils;
  Bitloader.Registry    = Registry;
  Bitloader.Loader      = Loader;
  Bitloader.Import      = Import;
  Bitloader.Module      = Module;
  Bitloader.Plugin      = Plugin;
  Bitloader.Resolver    = Resolver;
  Bitloader.Fetcher     = Fetcher;
  Bitloader.Compiler    = Compiler;
  Bitloader.Middleware  = Middleware;
  Bitloader.RuleMatcher = RuleMatcher;
  Bitloader.Logger      = Logger;
  module.exports        = Bitloader;
})();

},{"./import":13,"./interfaces/compiler":14,"./interfaces/fetcher":15,"./interfaces/resolver":16,"./loader":17,"./middleware":24,"./module":25,"./plugin":28,"./registry":29,"./rule-matcher":30,"./utils":32,"logger":18,"promise":10}],13:[function(require,module,exports){
(function() {
  "use strict";

  var Promise  = require('promise'),
      Registry = require('./registry'),
      Utils    = require('./utils');

  var getRegistryId = Registry.idGenerator('import');

  var ModuleState = {
    LOADING: "loading"
  };


  /**
   * Module importer. Primary function is to load Module instances and resolving
   * their dependencies in order to make the Module fully consumable.
   */
  function Import(manager) {
    if (!manager) {
      throw new TypeError("Must provide a manager");
    }

    this.manager = manager;
    this.context = Registry.getById(getRegistryId());
  }


  /**
   * Import is the method to load a Module
   *
   * @param {Array<string> | string} names - module(s) to import
   *
   * @returns {Promise}
   */
  Import.prototype.import = function(name, options) {
    options = options || {};
    var importer = this;

    if (typeof(name) === "string") {
      return Promise.resolve(importer._getModule(name, options));
    }

    return Promise.all(name.map(function getModuleByName(name) {
      return importer._getModule(name, options);
    }));
  };


  /**
   * Loops through the array of names, loading whatever has not yet been loaded,
   * and returning what has already been loaded.
   *
   * @param {Array<string>} names - Array of module names
   * @param {Object} options
   */
  Import.prototype._getModule = function(name, options) {
    var importer = this,
        manager  = this.manager;

    if (hasModule(options.modules, name)) {
      return options.modules[name];
    }
    else if (manager.hasModule(name)) {
      return manager.getModuleCode(name);
    }
    else if (importer.hasModule(name)) {
      return importer.getModule(name);
    }

    // Wrap in a separate promise to handle this:
    // https://github.com/MiguelCastillo/spromise/issues/35
    return new Promise(function deferredModuleResolver(resolve, reject) {
      importer.setModule(name, importer._loadModule(name))
        .then(function moduleSuccess(result) {
          resolve(result);
        }, function moduleError(error) {
          reject(error);
        });
    });
  };


  /**
   * Load module
   */
  Import.prototype._loadModule = function(name) {
    return this.manager
      .load(name)
      .then(this._getCodeDelegate(name), Utils.forwardError);
  };


  /**
   * Handler for when modules are loaded.
   */
  Import.prototype._getCodeDelegate = function(name) {
    var importer = this;

    return function getCodeDelegate(mod) {
      if (name !== mod.name) {
        return Promise.reject(new TypeError("Module name must be the same as the name used for loading the Module itself"));
      }

      importer.deleteModule(mod.name);
      return importer.manager.getModuleCode(mod.name);
    };
  };


  function hasModule(target, name) {
    return target && target.hasOwnProperty(name);
  }

  Import.prototype.hasModule = function(name) {
    return this.context.hasModuleWithState(ModuleState.LOADING, name);
  };

  Import.prototype.getModule = function(name) {
    return this.context.getModuleWithState(ModuleState.LOADING, name);
  };

  Import.prototype.setModule = function(name, item) {
    return this.context.setModule(ModuleState.LOADING, name, item);
  };

  Import.prototype.deleteModule = function(name) {
    return this.context.deleteModule(name);
  };

  module.exports = Import;
})();


},{"./registry":29,"./utils":32,"promise":10}],14:[function(require,module,exports){
(function() {
  "use strict";

  function Compiler() {
  }

  Compiler.prototype.compile = function(/*moduleMeta*/) {
    throw new TypeError("Compiler:compile is not implemented, must be implemented by the consumer code");
  };

  Compiler.prototype.canProcess = function(/*moduleMeta*/) {
    return false;
  };

  module.exports = Compiler;
})();

},{}],15:[function(require,module,exports){
(function() {
  "use strict";

  function Fetcher() {
  }

  Fetcher.prototype.fetch = function(/*name*/) {
    throw new TypeError("Fetcher:fetch is not implemented, must be implemented by the consumer code");
  };

  Fetcher.prototype.canProcess = function() {
    return false;
  };

  module.exports = Fetcher;
})();

},{}],16:[function(require,module,exports){
(function() {
  "use strict";

  function Resolver() {
  }

  Resolver.prototype.resolve = function(/*moduleMeta, moduleParent*/) {
    throw new TypeError("Resolver:resolve is not implemented, must be implemented by the consumer code");
  };

  Resolver.prototype.canProcess = function(/*moduleMeta*/) {
    return false;
  };

  module.exports = Resolver;
})();

},{}],17:[function(require,module,exports){
(function() {
  "use strict";

  var Promise        = require('promise'),
      Module         = require('./module'),
      Utils          = require('./utils'),
      Pipeline       = require('./pipeline'),
      Registry       = require('./registry'),
      moduleLinker   = require('./module/linker'),
      metaResolve    = require('./meta/resolve'),
      metaFetch      = require('./meta/fetch'),
      metaTransform  = require('./meta/transform'),
      metaDependency = require('./meta/dependency'),
      metaCompiler   = require('./meta/compiler');

  var getRegistryId = Registry.idGenerator('loader');


  /**
   * - Loading means that the module meta is currently being loaded. Only for ASYNC
   *  processing.
   *
   * - Loaded means that the module meta is all processed and it is ready to be
   *  built into a Module instance. Only for SYNC processing.
   *
   * - Pending means that the module meta is already loaded, but it needs it's
   *  dependencies processed, which might lead to further loading of module meta
   *  objects. Only for ASYNC processing.
   */
  var ModuleState = {
    LOADING: "loading",
    LOADED:  "loaded",
    PENDING: "pending"
  };


  /**
   * The purpose of Loader is to return full instances of Module.  Module instances
   * are stored in the manager's context to avoid loading the same module multiple times.
   * If the module is loaded, then we just return that.  If it has not bee loaded yet,
   * then we:
   *
   * 1. Fetch its source; remote server, local file system... You must specify a fetch
   *      provider to define how source files are retrieved
   * 2. Transform the source that was fetched.  This step enables processing of the
   *      source before it is compiled into an instance of Module.
   * 3. Compile the source that was fetched and transformed into a proper instance
   *      of Module
   * 4. Link the module
   */
  function Loader(manager) {
    if (!manager) {
      throw new TypeError("Must provide a manager");
    }

    this.manager  = manager;
    this.context  = Registry.getById(getRegistryId());
    this.pipeline = new Pipeline([metaTransform, metaDependency]);
  }


  /**
   * Handles the process of returning the instance of the Module if one exists, otherwise
   * the workflow for creating the instance is kicked off, which will eventually lead to
   * the creation of a Module instance
   *
   * The workflow is to take in a module name that needs to be loaded.  If a module with
   * the given name isn't loaded, then we fetch it.  The fetch call returns a promise, which
   * when resolved returns a moduleMeta. The moduleMeta is an intermediate object that contains
   * the module source from fetch and a compile method used for converting the source to an
   * instance of Module. The purporse for moduleMeta is to allow a tranformation pipeline to
   * process the raw source before building the final product - a Module instance. The
   * transformation pipeline allows us to do things like convert coffeescript to javascript.
   *
   * Primary workflow:
   * fetch     -> module name {string}
   * transform -> module meta {compile:fn, source:string}
   * load deps -> module meta {compile:fn, source:string}
   * compile moduleMeta
   * link module
   *
   * @param {string} name - The name of the module to load.
   *
   * @returns {Promise} - Promise that will resolve to a Module instance
   */
  Loader.prototype.load = function(name, parentMeta) {
    var loader  = this,
        manager = this.manager;

    if (!name) {
      return Promise.reject(new TypeError("Must provide the name of the module to load"));
    }

    // Take a look if the module is already loaded
    if (manager.hasModule(name)) {
      return Promise.resolve(manager.getModule(name));
    }

    // Check if the module is fetch or registered
    if (loader.isLoaded(name) || loader.isPending(name)) {
      return Promise.resolve(build());
    }

    function build() {
      return loader.asyncBuild(name);
    }

    return loader
      .fetch(name, parentMeta)
      .then(build, Utils.forwardError);
  };


  /**
   * This method fetches the module meta if it is not already loaded. Once the
   * the module meta is fetched, it is sent through the transform pipeline. Once
   * the transformation is done, all dependencies are fetched.
   *
   * The purpose for this method is to setup the module meta and all its dependencies
   * so that the module meta can be converted to an instance of Module synchronously.
   *
   * Use this method if the intent is to preload dependencies without actually compiling
   * module metas to instances of Module.
   *
   * @param {string} name - The name of the module to fetch
   * @returns {Promise}
   */
  Loader.prototype.fetch = function(name, parentMeta) {
    var loader  = this,
        manager = this.manager;

    if (!name) {
      return Promise.reject(new TypeError("Must provide the name of the module to fetch"));
    }

    // Take a look if the module is already loaded
    if (manager.hasModule(name)) {
      return Promise.resolve();
    }

    // Check if the module is being fetched
    if (loader.isLoading(name)) {
      return loader.getLoading(name);
    }


    function moduleMetaFetch(moduleMeta) {
      return loader._fetchModuleMeta(moduleMeta);
    }

    function moduleMetaPipeline(moduleMeta) {
      return loader._pipelineModuleMeta(moduleMeta);
    }

    function moduleMetaFinished(moduleMeta) {
      return loader.setLoaded(moduleMeta.name, moduleMeta);
    }

    var loading = loader
      ._resolveModuleMeta(name, parentMeta)
      .then(moduleMetaFetch,    Utils.printError)
      .then(moduleMetaPipeline, Utils.printError)
      .then(moduleMetaFinished, Utils.printError);

    return loader.setLoading(name, loading);
  };


  /**
   * Converts a module meta object to a full Module instance.
   *
   * @param {string} name - The name of the module meta to convert to an instance of Module.
   *
   * @returns {Module} Module instance from the conversion of module meta
   */
  Loader.prototype.syncBuild = function(name) {
    var mod = this._compileModuleMeta(name);

    if (!mod) {
      if (this.isPending(name)) {
        throw new TypeError("Unable to synchronously build dynamic module '" + name + "'");
      }
      else {
        throw new TypeError("Unable to synchronously build module '" + name + "'");
      }
    }

    return this._linkModule(mod);
  };


  /**
   * Build module handling any async Module registration.  What this means is that if a module
   * is being loaded and it calls System.register to register itself, then it needs to be handled
   * as an async step because that could be loading other dependencies.
   *
   * @param {string} name - Name of the target Module
   *
   * @returns {Promise}
   */
  Loader.prototype.asyncBuild = function(name) {
    var loader = this;
    var mod;

    if (loader.isLoaded(name)) {
      mod = loader._compileModuleMeta(name);
    }
    else if (loader.manager.hasModule(name)) {
      return Promise.resolve(loader.manager.getModule(name));
    }

    // If the module evaluation didn't register a new module, then we return whatever
    // was produced.
    if (!loader.isPending(name)) {
      return Promise.resolve(loader._linkModule(mod));
    }

    // Right here is where we handle dynamic registration of modules while are being loaded.
    // E.g. System.register to register a module that's being loaded
    return metaDependency(loader.manager, loader.deleteModule(name))
      .then(buildDependencies, Utils.forwardError)
      .then(linkModuleMeta, Utils.forwardError);


    //
    // Helper methods
    //

    function buildDependencies(moduleMeta) {
      var pending = moduleMeta.deps.map(function buildDependency(moduleName) {
        return loader.asyncBuild(moduleName);
      });

      return Promise.all(pending)
        .then(function dependenciesBuilt() {
          return moduleMeta;
        }, Utils.forwardError);
    }

    function linkModuleMeta(moduleMeta) {
      return loader._linkModule(new Module(moduleMeta));
    }
  };


  /**
   * Interface to register a module meta that can be put compiled to a Module instance
   */
  Loader.prototype.register = function(name, deps, factory, type) {
    if (this.manager.hasModule(name) || this.hasModule(name)) {
      throw new TypeError("Module '" + name + "' is already loaded");
    }

    this.setPending(name, {
      name    : name,
      deps    : deps,
      factory : factory,
      type    : type
    });
  };


  /**
   * Utility helper that runs a module meta object through the transformation workflow.
   * The module meta object passed *must* have a string source property, which is what
   * the transformation workflow primarily operates against.
   *
   * @param {object} moduleMeta - Module meta object with require `source` property that
   *  is processed by the transformation pipeline.
   *
   * @returns {Promise} That when resolved, the fully tranformed module meta is returned.
   *
   */
  Loader.prototype.transform = function(moduleMeta) {
    if (!moduleMeta) {
      return Promise.reject(new TypeError("Must provide a module meta object"));
    }

    if (typeof(moduleMeta.source) !== "string") {
      throw Promise.reject(new TypeError("Must provide a source string property with the content to transform"));
    }

    moduleMeta.deps = moduleMeta.deps || [];
    return metaTransform(this.manager, moduleMeta);
  };


  /**
   * Method that converts module names to a module meta objects that is then fetched,
   * fed through the pipeline, and eventually built into a Module instance.
   *
   * @param {string} name - Module name for which to build the module meta for.
   * @param {Module.Meta} parentMeta - Is the module meta object that is initiating the
   *   current transaction
   *
   * @returns {Promise} When resolved, a module meta instance is returned
   */
  Loader.prototype._resolveModuleMeta = function(name, parentMeta) {
    return metaResolve(this.manager, name, parentMeta);
  };


  /**
   * Method that fetches the content of a module from storage, via XHR, file system, or
   * whatever fetch provider is configured
   *
   * @param {Module.Meta} moduleMeta - Module meta
   *
   * @returns {Promise} When resolved, a module meta that has gone through the pipeline
   *   is returned.
   */
  Loader.prototype._fetchModuleMeta = function(moduleMeta) {
    return metaFetch(this.manager, moduleMeta);
  };


  /**
   * Put a module meta object through the pipeline, which includes the transformation
   * and dependency loading stages.
   *
   * @param {Module.Meta} moduleMeta - Module meta object to run through the pipeline.
   *
   * @returns {Promise} that when fulfilled, the processed module meta object is returned.
   */
  Loader.prototype._pipelineModuleMeta = function(moduleMeta) {
    if (Module.Meta.isCompiled(moduleMeta)) {
      return Promise.resolve(moduleMeta);
    }

    return this.pipeline
      .run(this.manager, moduleMeta)
      .then(pipelineFinished, Utils.forwardError);

    function pipelineFinished() {
      return moduleMeta;
    }
  };


  /**
   * Convert a module meta object into a proper Module instance.
   *
   * @param {string} name - Name of the module meta object to be converted.
   *
   * @returns {Module}
   */
  Loader.prototype._compileModuleMeta = function(name) {
    var moduleMeta;
    var manager = this.manager;

    if (this.isLoaded(name)) {
      moduleMeta = this.deleteModule(name);
    }
    else if (this.manager.isModuleCached(name)) {
      throw new TypeError("Module `" + name + "` is already loaded, so you can just call `manager.getModule(name)`");
    }
    else {
      throw new TypeError("Module `" + name + "` is not loaded yet. Make sure to call `load` or `fetch` prior to calling `linkModuleMeta`");
    }

    // Compile module meta to create a Module instance
    return metaCompiler(manager, moduleMeta);
  };


  /**
   * Finalizes a Module instance by pulling in all the dependencies and calling the module
   * factory method if available.  This is the very last stage of the Module building process
   *
   * @param {Module} mod - Module instance to link
   *
   * @returns {Module} Instance all linked
   */
  Loader.prototype._linkModule = function(mod) {
    if (!(mod instanceof(Module))) {
      throw new TypeError("Module `" + mod.name + "` is not an instance of Module");
    }

    ////
    // This is the sweet spot when synchronous build process and dynamic module registration meet.
    //
    // Module registration/import are async operations. Build process is sync.  So the challenge
    // is to make sure these two don't cross paths.  We solve this problem by making sure we
    // only process pending module meta objects in async module loading methods such as
    // `import`, because that method is asynchronous.  We want async operations to run early
    // and finish all they work.  And then ONLY run sync operations so that calls like `require`
    // can behave synchronously.
    ////
    if (this.isPending(mod.name)) {
      console.warn("Module '" + mod.name + "' is being dynamically registered while being loaded.", "You don't need to call 'System.register' when the module is already being loaded.");
    }

    // Run the Module instance through the module linker
    return moduleLinker(this.manager, mod);
  };


  /**
   * Check if there is currently a module loading or loaded.
   *
   * @param {string} name - The name of the module meta to check
   *
   * @returns {Boolean}
   */
  Loader.prototype.hasModule = function(name) {
    return this.context.hasModule(name);
  };


  /**
   * Method to retrieve the module meta with the given name, if one exists.  If it
   * is loading, then the promise for the pending request is returned. Otherwise
   * the actual module meta object is returned.
   *
   * @param {string} name - The name of the module meta to get
   *
   * @returns {object | Promise}
   */
  Loader.prototype.getModule = function(name) {
    return this.context.getModule(name);
  };


  /**
   * Checks if the module meta with the given name is currently loading
   *
   * @param {string} name - The name of the module meta to check
   *
   * @returns {Boolean} - true if the module name is being loaded, false otherwise.
   */
  Loader.prototype.isLoading = function(name) {
    return this.context.hasModuleWithState(ModuleState.LOADING, name);
  };


  /**
   * Method to retrieve the module meta with the given name, if it is loading.
   *
   * @param {string} name - The name of the loading module meta to get.
   *
   * @returns {Promise}
   */
  Loader.prototype.getLoading = function(name) {
    return this.context.getModuleWithState(ModuleState.LOADING, name);
  };


  /**
   * Method to set the loading module meta with the given name.
   *
   * @param {string} name - The name of the module meta to set
   * @param {Object} item - The module meta to set
   *
   * @returns {Object} The module meta being set
   */
  Loader.prototype.setLoading = function(name, item) {
    return this.context.setModule(ModuleState.LOADING, name, item);
  };


  /**
   * Method to check if a module meta object is in a pending state, which means
   * that all it needs is have its dependencies loaded and then it's ready to
   * to be compiled.
   *
   * @param {string} name - Name of the module meta object
   *
   * @returns {Boolean}
   */
  Loader.prototype.isPending = function(name) {
    return this.context.hasModuleWithState(ModuleState.PENDING, name);
  };


  /**
   * Method to get a module meta object to the pending state.
   *
   * @param {string} name - Name of the module meta to get
   *
   * @returns {Object} Module meta object
   */
  Loader.prototype.getPending = function(name) {
    return this.context.getModuleWithState(ModuleState.PENDING, name);
  };


  /**
   * Method to set a module meta object to the pending state.
   *
   * @param {string} name - Name of the module meta object
   * @param {Object} item - Module meta object to be set
   *
   * @returns {Object} Module meta being set
   */
  Loader.prototype.setPending = function(name, item) {
    return this.context.setModule(ModuleState.PENDING, name, item);
  };


  /**
   * Method to check if a module meta with the given name is already loaded.
   *
   * @param {string} name - The name of the module meta to check.
   *
   * @returns {Boolean}
   */
  Loader.prototype.isLoaded = function(name) {
    return this.context.hasModuleWithState(ModuleState.LOADED, name);
  };


  /**
   * Method to retrieve the module meta with the given name, if one exists.
   *
   * @param {string} name - The name of the loaded module meta to set
   *
   * @returns {Object} The loaded module meta
   */
  Loader.prototype.getLoaded = function(name) {
    return this.context.getModuleWithState(ModuleState.LOADED, name);
  };


  /**
   * Method to set the loaded module meta with the given name
   *
   * @param {string} name - The name of the module meta to set
   * @param {Object} item - The module meta to set
   *
   * @returns {Object} The module meta being set
   */
  Loader.prototype.setLoaded = function(name, item) {
    return this.context.setModule(ModuleState.LOADED, name, item);
  };


  /**
   * Method to remove the module from storage
   *
   * @param {string} name - The name of the module meta to remove
   *
   * @returns {Object} The module meta being removed
   */
  Loader.prototype.deleteModule = function(name) {
    return this.context.deleteModule(name);
  };


  module.exports = Loader;
})();

},{"./meta/compiler":19,"./meta/dependency":20,"./meta/fetch":21,"./meta/resolve":22,"./meta/transform":23,"./module":25,"./module/linker":26,"./pipeline":27,"./registry":29,"./utils":32,"promise":10}],18:[function(require,module,exports){
(function() {
  "use strict";

  var _enabled = false;
  var _only    = false;
  var noop     = function noop() {};


  /**
   * @class
   * Logger instance with a name
   *
   * @param {string} name - Name of the logger
   */
  function Logger(name, options) {
    options = options || {};
    this.name     = name;
    this._enabled = true;
    this._target  = ensureTarget(options._target);
  }


  /**
   * Helper factory method to create named loggers
   */
  Logger.prototype.factory = function(name, options) {
    return new Logger(name, options);
  };


  /**
   * Method to log a message.
   *
   * Verifies that logger is enabled. If it is enabled, then the message(s) are
   * logged. Otherwise ignored.
   */
  Logger.prototype.log = function() {
    if (!this.isEnabled()) {
      return;
    }

    this._target.log.apply(this._target, [getDate(), this.name].concat(arguments));
  };


  /**
   * Method to log JSON.
   *
   * Verifies that the logger is enabled. If it is enabled, then the input JSON
   * is logged.  Otherwise ignored.
   */
  Logger.prototype.dir = function() {
    if (!this.isEnabled()) {
      return;
    }

    this._target.dir.apply(this._target, arguments);
  };


  /**
   * Method to log errors.
   *
   * Verifies that the logger is enabled. If it is enabled, then the error(s)
   * are logged.  Otherwise ignored.
   */
  Logger.prototype.error = function() {
    if (!this.isEnabled()) {
      return;
    }

    this._target.error.apply(this._target, arguments);
  };


  /**
   * Checks if the logger can write messages.
   *
   * @returns {boolean}
   */
  Logger.prototype.isEnabled = function() {
    return this._enabled && _enabled && (!_only || _only === this.name);
  };


  /**
   * Method to enable the logger intance. If loggers have been disabled
   * globally then this flag will not have an immediate effect, until
   * loggers are globally enabled.
   */
  Logger.prototype.enable = function() {
    this._enabled = true;
  };


  /**
   * Method to disable the logger instance. Like {@link Logger#enable},
   * this setting does not have an immediate effect if loggers are globally
   * disabled.
   */
  Logger.prototype.disable = function() {
    this._enabled = false;
  };


  /**
   * Method to make sure only this logger logs messages. If another logger is
   * set to only, then the request is silently ignored.
   */
  Logger.prototype.only = function() {
    if (!Logger._only) {
      Logger._only = this.name;
    }
  };


  /**
   * Method to remove the logger from the `only` state to allow other loggers
   * set themselves as only.
   */
  Logger.prototype.all = function() {
    Logger._only = null;
  };


  /**
   * Disables loggers globally.
   */
  Logger.prototype.disableAll = function() {
    Logger.disable();
  };


  /**
   * Enables loggers globally.
   */
  Logger.prototype.enableAll = function() {
    Logger.enable();
  };


  // Expose the constructor to be able to create new instances from an
  // existing instance.
  Logger.prototype.Logger = Logger;


  /**
   * Underlying method to enable all logger instances
   *
   * @private
   */
  Logger.enable  = function() {
    _enabled = true;
  };


  /**
   * Underlying method to disable all logger instances
   *
   * @private
   */
  Logger.disable = function() {
    _enabled = false;
  };


  /**
   * Underlying method to set the `only` logger instance that can log message
   *
   * @private
   */
  Logger.only = function(name) {
    _only = name;
  };


  /**
   * Underlying method to remove the `only` logger instance that can log
   * message
   *
   * @private
   */
  Logger.all = function() {
    _only = null;
  };


  /**
   * Returns a valid console interface with three methods:
   * - log, which logs raw text messages.
   * - error, which logs errors including exceptions.
   * - dir, which logs JSON
   *
   * @returns {{log: function, error: function, dir: function}}
   */
  function getConsole() {
    var _result;
    if (typeof(console) !== 'undefined') {
      _result = console;
    }
    else {
      _result = {log: noop, error: noop, dir: noop};
    }
    return _result;
  }


  /**
   * Method that fills in the target object to make sure we have a valid target
   * we are writing to.
   */
  function ensureTarget(target) {
    if (!target) {
      return getConsole();
    }

    target.log   = target.log   || noop;
    target.error = target.error || noop;
    target.dir   = target.dir   || noop;
    return target;
  }


  /**
   * Helper method to get timestamps for logged message
   *
   * @private
   */
  function getDate() {
    return (new Date()).getTime();
  }


  /**
   * Default logger instance available
   */
  module.exports = new Logger();
}());

},{}],19:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Module  = require('../module'),
      logger  = require('logger').factory("Meta/Compiler");

  /**
   * The compile step is to convert the moduleMeta to an instance of Module. The
   * fetch provider is in charge of adding the compile interface in the moduleMeta
   * as that is the place with the most knowledge about how the module was loaded
   * from the server/local file system.
   */
  function MetaCompiler(manager, moduleMeta) {
    logger.log(moduleMeta.name, moduleMeta);

    if (manager.rules.ignore.match(moduleMeta.name, "compiler")) {
      return Promise.resolve();
    }

    var mod;
    if (Module.Meta.canCompile(moduleMeta)) {
      mod = manager.compile(moduleMeta);
    }
    else if (Module.Meta.isCompiled(moduleMeta)) {
      mod = new Module(moduleMeta);
    }

    if (mod) {
      // We will coerce the name no matter what name (if one at all) the Module was
      // created with. This will ensure a consistent state in the loading engine.
      mod.name = moduleMeta.name;

      // Set the mod.meta for convenience
      mod.meta = moduleMeta;
      return mod;
    }
  }

  module.exports = MetaCompiler;
})();

},{"../module":25,"logger":18,"promise":10}],20:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Module  = require('../module'),
      Utils   = require('../utils'),
      logger  = require('logger').factory("Meta/Dependency");


  /**
   * Loads up all dependencies for the module
   *
   * @returns {Function} callback to call with the Module instance with the
   *   dependencies to be resolved
   */
  function MetaDependency(manager, moduleMeta) {
    logger.log(moduleMeta.name, moduleMeta);

    if (manager.rules.ignore.match(moduleMeta.name, "dependency")) {
      return Promise.resolve(moduleMeta);
    }

    function dependenciesFinished() {
      // Return if the module has no dependencies
      if (!Module.Meta.hasDependencies(moduleMeta)) {
        return moduleMeta;
      }

      return loadDependencies(manager, moduleMeta);
    }

    if (runPlugins(moduleMeta.plugins)) {
      return manager.pipelines.dependency
        .run(moduleMeta.plugins, moduleMeta)
        .then(dependenciesFinished, Utils.forwardError);
    }
    else {
      return manager.pipelines.dependency
        .runAll(moduleMeta)
        .then(dependenciesFinished, Utils.forwardError);
    }
  }


  function loadDependencies(manager, moduleMeta) {
    var i, length, loading = new Array(moduleMeta.deps.length);

    for (i = 0, length = moduleMeta.deps.length; i < length; i++) {
      loading[i] = manager.providers.loader.fetch(moduleMeta.deps[i], moduleMeta);
    }

    function dependenciesFetched() {
      return moduleMeta;
    }

    return Promise.all(loading).then(dependenciesFetched, Utils.forwardError);
  }


  function runPlugins(plugins) {
    return plugins && plugins.length && !(plugins.length === 1 && !plugins[0]);
  }


  module.exports = MetaDependency;
})();

},{"../module":25,"../utils":32,"logger":18,"promise":10}],21:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Utils   = require('../utils'),
      logger  = require('logger').factory("Meta/Fetch");

  function MetaFetch(manager, moduleMeta) {
    logger.log(moduleMeta);

    if (manager.rules.ignore.match(moduleMeta.name, "fetch")) {
      return Promise.resolve(moduleMeta);
    }

    return Promise.resolve(manager.fetch(moduleMeta))
      .then(function(meta) {
        return moduleMeta.configure(meta);
      }, Utils.reportError);
  }

  module.exports = MetaFetch;
})();

},{"../utils":32,"logger":18,"promise":10}],22:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Module  = require('../module'),
      Utils   = require('../utils'),
      logger  = require('logger').factory("Meta/Resolve");

  function MetaResolve(manager, name, parentMeta) {
    logger.log(name);

    var moduleMeta = new Module.Meta(name);

    return Promise.resolve(manager.resolve(moduleMeta, parentMeta))
      .then(function(meta) {
        meta = meta || {};
        if (!meta.cname) {
          meta.cname = meta.name;
        }

        delete meta.name;
        return moduleMeta.configure(meta);
      }, Utils.reportError);
  }

  module.exports = MetaResolve;
})();

},{"../module":25,"../utils":32,"logger":18,"promise":10}],23:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Plugin  = require('../plugin'),
      Utils   = require('../utils'),
      logger  = require('logger').factory("Meta/Tranform");

  /**
   * The transform enables transformation providers to process the moduleMeta
   * before it is compiled into an actual Module instance.  This is where steps
   * such as linting and processing coffee files can take place.
   */
  function MetaTransform(manager, moduleMeta) {
    logger.log(moduleMeta.name, moduleMeta);

    if (manager.rules.ignore.match(moduleMeta.name, "transform")) {
      return Promise.resolve(moduleMeta);
    }

    function transformationFinished() {
      return moduleMeta;
    }

    if (runPlugins(moduleMeta.plugins)) {
      return manager.pipelines.transform
        .run(moduleMeta.plugins, moduleMeta, Plugin.createCanExecute(moduleMeta))
        .then(transformationFinished, Utils.forwardError);
    }
    else {
      return manager.pipelines.transform
        .runAll(moduleMeta, Plugin.createCanExecute(moduleMeta))
        .then(transformationFinished, Utils.forwardError);
    }
  }


  function runPlugins(plugins) {
    return plugins && plugins.length && !(plugins.length === 1 && !plugins[0]);
  }


  module.exports = MetaTransform;
})();

},{"../plugin":28,"../utils":32,"logger":18,"promise":10}],24:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Utils   = require('./utils'),
      logger  = require('logger').factory("Middleware");


  /**
   * @constructor For checking middleware provider instances
   */
  function Provider() {
  }


  /**
   * Method to test if the provider handler can be called.  Override this method
   * to customize how it is determined if a provider should be executed or not.
   */
  Provider.prototype.canExecute = function() {
    if (!Utils.isFunction(this.handler)) {
      throw new TypeError("Middleware provider handler must be implemented");
    }
    return true;
  };


  /**
   * Method that determines if the handler should be called and then calls
   * if need be.
   *
   * @returns {Promise} Promise returned from the call to the handler.
   */
  Provider.prototype.execute = function(data) {
    if (this.canExecute.apply(this, data)) {
      return this.handler.apply(this, data);
    }
  };


  /**
   * Middleware provides a mechanism for registering `plugins` that can be
   * called in the order in which they are registered.  These middlewares can
   * be module names that can be loaded at runtime or can be functions.
   */
  function Middleware(options) {
    this.settings  = options || {};
    this.providers = [];
    this.named     = {};
  }


  /**
   * Method to register middleware providers. Providers can be methods, a module name,
   * or an object.
   *
   * For example, the provider below is just a method that will get invoked when
   * running the entire sequence of providers. The provider is registered as an
   * anonymous provider.
   *
   * ``` javascript
   * middleware.use(function() {
   *   console.log("1");
   * });
   * ```
   *
   * But registering a provider as a name will cause the middleware engine to
   * dynamically load it at runtime, and can also be executed by name.
   *
   * ``` javascript
   * middleware.use(`concat`);
   * middleware.run(`concat`);
   * ```
   *
   * The alternative for registering named providers is to pass in a `Object` with a
   * `handler` method and a `name`.  The name is only required if you are interested in
   * more control for executing the provider.
   *
   * ``` javascript
   * middleware.use({
   *  name: "concat",
   *  handler: function() {
   *  }
   * });
   *
   * // Will only run `concat`
   * middleware.run(`concat`);
   *
   * // Will run all registered providers, including `concat`
   * middleware.runAll();
   * ```
   *
   * @param {Object | Array<Object>} providers - One or collection of providers to
   *   be registered in this middleware instance.
   *
   * @returns {Middleware} Returns instance of Middleware
   */
  Middleware.prototype.use = function(providers) {
    if (!Utils.isArray(providers)) {
      providers = [providers];
    }

    var i, length, provider, options;
    for (i = 0, length = providers.length; i < length; i++) {
      options = providers[i];

      if (!options) {
        throw new TypeError("Middleware provider must not be empty");
      }

      if (this.hasProvider(options.name)) {
        Middleware.configureProvider(this, this.getProvider(options.name), options);
      }
      else {
        provider = Middleware.createProvider(this, options);
        this.providers.push(provider);

        if (Utils.isString(provider.name)) {
          this.named[provider.name] = provider;
        }
      }
    }

    return this;
  };


  /**
   * Gets the middleware provider by name.  It also handles when the middlware
   * handler does not exist.
   *
   * @returns {Provider}
   */
  Middleware.prototype.getProvider = function(name) {
    if (!this.named.hasOwnProperty(name)) {
      throw new TypeError("Middleware provider '" + name + "' does not exist");
    }

    return this.named[name];
  };


  /**
   * Determines whether or not the provider with the specific name is already
   * registered.
   *
   * @param {string} name - Name of the provider.
   * @returns {boolean} Whether or not the named provider is already registered
   */
  Middleware.prototype.hasProvider = function(name) {
    return this.named.hasOwnProperty(name);
  };


  /**
   * Creates an array of Providers from the array of names
   *
   * @param {string | Array.<string>} names - Name of collection of provider names
   *   to be returned in an array of providers.
   *
   * @returns {Array.<Provider>} Array of providers.
   */
  Middleware.prototype.filterProviders = function(names) {
    if (Utils.isString(names)) {
      names = [names];
    }

    if (!Utils.isArray(names)) {
      throw new TypeError("List of handlers must be a string or an array of names");
    }

    var i, length;
    var providers = [];

    for (i = 0, length = names.length; i < length; i++) {
      if (this.hasProvider(names[i])) {
        providers.push(this.getProvider(names[i]));
      }
    }

    return providers;
  };


  /**
   * Method that runs `named` providers.  You can pass in a name of the provider
   * to be executed or an array of names.  If passing in an array, the providers
   * will be executed in the order in which they are in the array; regardless of
   * the order in which they were registered.
   *
   * @param {string | Array<string>} names - Name(s) of the providers to run
   *
   * @returns {Promise}
   */
  Middleware.prototype.run = function(names, data, canExecuteProvider) {
    if (data && !Utils.isArray(data)) {
      data = [data];
    }

    var providers = this.filterProviders(names);
    return _runProviders(providers, data, canExecuteProvider);
  };


  /**
   * Method that runs the first found `named` provider.  You can pass in a name of
   * the provider to be executed or an array of names to chose from.
   *
   * @param {string | Array<string>} names - Name(s) of the providers to run
   *
   * @returns {Promise}
   */
  Middleware.prototype.runFirst = function(names, data, canExecuteProvider) {
    if (data && !Utils.isArray(data)) {
      data = [data];
    }

    var providers = this.filterProviders(names).shift();
    return _runProviders(providers ? [providers] : [], data, canExecuteProvider);
  };


  /**
   * Method to run all registered providers in the order in which they were
   * registered.
   *
   * @returns {Promise}
   */
  Middleware.prototype.runAll = function(data, canExecuteProvider) {
    if (data && !Utils.isArray(data)) {
      data = [data];
    }

    return _runProviders(this.providers, data, canExecuteProvider);
  };


  /**
   * @private
   *
   * Method to configure providers.
   */
  Middleware.configureProvider = function(middleware, provider, options) {
    if (Utils.isFunction(provider.configure)) {
      provider.configure(options);
    }
    if (Utils.isFunction(options)) {
      provider.handler = options;
    }
    else if (Utils.isString(options)) {
      provider.name = options;

      if (!Utils.isFunction(provider.handler)) {
        provider.handler = Middleware.deferredHandler(middleware, provider);
      }
    }
    else if (Utils.isPlainObject(options)) {
      if (!Utils.isFunction(options.handler) && !Utils.isFunction(provider.handler)) {
        if (Utils.isString(options.name)) {
          options.handler = Middleware.deferredHandler(middleware, provider);
        }
        else {
          throw new TypeError("Middleware provider must have a handler method or a name");
        }
      }

      Utils.extend(provider, options);
    }

    return provider;
  };


  /**
   * @private
   *
   * Provider factory
   */
  Middleware.createProvider = function(middleware, options) {
    var provider;

    if (Utils.isFunction(options) || Utils.isString(options) || Utils.isPlainObject(options)) {
      provider = Middleware.configureProvider(middleware, new Provider(), options);
    }

    return provider || options;
  };


  /**
   * @private
   *
   * Method that enables chaining in providers that have to be dynamically loaded.
   */
  Middleware.deferredHandler = function(middleware, provider) {
    if (!middleware.settings.import) {
      throw new TypeError("You must configure an import method in order to dynamically load middleware providers");
    }

    function importProvider() {
      if (!provider.__deferred) {
        logger.log("import [start]", provider);
        provider.__deferred = middleware.settings
          .import(provider.name)
          .then(providerImported, Utils.reportError);
      }
      else {
        logger.log("import [pending]", provider);
      }

      return provider.__deferred;
    }

    function providerImported(result) {
      logger.log("import [end]", provider);
      delete provider.__deferred;
      Middleware.configureProvider(middleware, provider, result);
    }


    return function deferredHandlerDelegate() {
      var data = arguments;

      // Callback when provider is loaded
      function providerReady() {
        return provider.execute(data);
      }

      return importProvider().then(providerReady, Utils.reportError);
    };
  };


  /**
   * @private
   *
   * Method that runs a cancellable sequence of promises.
   *
   * When a provider is executed, sequence execution can be terminated by returning
   * false. You can also `throw` to teminate the execution.
   *
   * The only thing a provider can return is a promise, which is really useful
   * if the provider needs to do some work asynchronously.
   */
  function _runProviders(providers, data, canExecuteProvider) {
    // Method that runs the sequence of providers
    function providerSequence(result, provider) {
      var cancelled = false;

      function providerSequenceRun(result) {
        if (result === false) {
          cancelled = true;
        }

        if (!cancelled) {
          if (!canExecuteProvider || (canExecuteProvider && canExecuteProvider(provider) !== false)) {
            return provider.execute(data);
          }
        }
      }

      function providerSequenceError(err) {
        cancelled = true;
        return err;
      }

      return result.then(providerSequenceRun, providerSequenceError);
    }

    return providers.reduce(providerSequence, Promise.resolve());
  }


  Middleware.Provider = Provider;
  module.exports = Middleware;
}());

},{"./utils":32,"logger":18,"promise":10}],25:[function(require,module,exports){
(function() {
  "use strict";

  var Utils = require('./utils');

  var Type = {
    "UNKNOWN" : "UNKNOWN",
    "AMD"     : "AMD",     //Asynchronous Module Definition
    "CJS"     : "CJS",     //CommonJS
    "IIFE"    : "IIFE"     //Immediately-Invoked Function Expression
  };


  function Module(options) {
    if (!options) {
      throw new TypeError("Must provide options to create the module");
    }

    if (options.hasOwnProperty("code")) {
      this.code = options.code;
    }

    if (options.hasOwnProperty("factory")) {
      this.factory = options.factory;
    }

    this.type     = options.type || Type.UNKNOWN;
    this.name     = options.name;
    this.deps     = options.deps ? options.deps.slice(0) : [];
    this.settings = Utils.extend({}, options);
  }


  /**
   * Module meta object
   */
  function Meta(options) {
    options = options || {};
    if (Utils.isString(options)) {
      options = {
        name: options
      };
    }

    if (!Utils.isString(options.name)) {
      throw new TypeError("Must provide a name, which is used by the resolver to create a location for the resource");
    }

    if (!Utils.isArray(options.deps)) {
      delete options.deps;
      this.deps = [];
    }

    this.configure(options);
  }


  Meta.prototype.configure = function(options) {
    Utils.extend(this, options);
    return this;
  };


  Meta.validate = function(moduleMeta) {
    if (!moduleMeta) {
      throw new TypeError("Must provide options");
    }

    if (!Meta.isCompiled(moduleMeta) && !Meta.canCompile(moduleMeta)) {
      throw new TypeError("ModuleMeta must provide a `source` string or `code`.");
    }
  };


  Meta.hasDependencies = function(moduleMeta) {
    return moduleMeta.deps && moduleMeta.deps.length;
  };


  Meta.isCompiled = function(moduleMeta) {
    return moduleMeta.hasOwnProperty("code") || typeof(moduleMeta.factory) === "function";
  };


  Meta.canCompile = function(moduleMeta) {
    return !Meta.isCompiled(moduleMeta) && typeof(moduleMeta.source) === "string";
  };


  Module.Meta = Meta;
  Module.Type = Type;
  module.exports = Module;
})();

},{"./utils":32}],26:[function(require,module,exports){
(function(root) {
  "use strict";

  var logger = require('logger').factory("Module/Linker");

  function ModuleLinker(manager, mod) {
    function traverseDependencies(mod) {
      logger.log(mod.name, mod);

      // Get all dependencies to feed them to the module factory
      var deps = mod.deps.map(function resolveDependency(mod_name) {
        if (manager.isModuleCached(mod_name)) {
          return manager.getModuleCode(mod_name);
        }

        return traverseDependencies(manager.getModule(mod_name)).code;
      });

      if (mod.factory && !mod.hasOwnProperty("code")) {
        mod.code = mod.factory.apply(root, deps);
      }

      return mod;
    }

    return manager.setModule(traverseDependencies(mod));
  }

  module.exports = ModuleLinker;
})(typeof(window) !== 'undefined' ? window : this);

},{"logger":18}],27:[function(require,module,exports){
(function() {
  "use strict";

  var Promise = require('promise'),
      Utils   = require('./utils');

  function Pipeline(assets) {
    this.assets = assets;
  }

  Pipeline.prototype.run = function() {
    var args = arguments;
    function cb(curr) {
      return function pipelineAssetReady() {
        return curr.apply((void 0), args);
      };
    }

    return this.assets.reduce(function(prev, curr) {
      return prev.then(cb(curr), Utils.forwardError);
    }, Promise.resolve());
  };

  module.exports = Pipeline;
})();

},{"./utils":32,"promise":10}],28:[function(require,module,exports){
(function() {
  "use strict";

  var Promise     = require("promise");
  var Utils       = require("./utils");
  var RuleMatcher = require("./rule-matcher");
  var logger      = require("./logger").factory('Plugin');

  var pluginId = 0;


  /**
   * Plugin
   */
  function Plugin(name, settings) {
    settings = settings || {};
    this.name       = name || ("plugin-" + (pluginId++));
    this.settings   = settings;
    this.services   = settings.services || settings.pipelines;
    this._matches   = {};
    this._delegates = {};
    this._handlers  = {};
    this._deferred  = {};
  }


  /**
   * Configure plugin
   */
  Plugin.prototype.configure = function(options) {
    var settings = Utils.merge({}, options);

    // Add matching rules
    for (var match in settings.match) {
      if (!settings.match.hasOwnProperty(match)) {
        continue;
      }

      this.addMatchingRules(match, settings.match[match]);
    }

    // Hook into the different services
    for (var serviceName in settings) {
      if (!settings.hasOwnProperty(serviceName) || serviceName === "match") {
        continue;
      }

      this.addHandlers(settings[serviceName], serviceName);
    }

    return this;
  };


  /**
   * Method for adding matching rules used for determining if a
   * module meta should be processed by the plugin or not.
   */
  Plugin.prototype.addMatchingRules = function(name, matches) {
    var rules;
    if (matches && matches.length) {
      rules = this._matches[name] || (this._matches[name] = new RuleMatcher());
      rules.add(configureMatchingRules(matches));
    }

    return this;
  };


  /**
   * Adds handlers for the particular service.
   */
  Plugin.prototype.addHandlers = function(handlers, serviceName) {
    if (!this.services.hasOwnProperty(serviceName)) {
      throw new TypeError("Unable to register plugin for '" + serviceName + "'. '" + serviceName + "' is not found");
    }

    // Make sure we have a good plugin's configuration settings for the service.
    this._handlers[serviceName] = configureHandlers(this, serviceName, handlers);

    // Register service delegate if one does not exist.  Delegates are the callbacks
    // registered with the service that when called, the plugins executes all the
    // plugin's handlers in a promise sequence.
    if (!this._delegates[serviceName]) {
      this._delegates[serviceName] = createHandlerDelegate(this, serviceName);
      registerHandlerDelegate(this, this.services[serviceName], this._delegates[serviceName]);
    }

    return this;
  };


  /**
   * Configures matches
   */
  function configureMatchingRules(matches) {
    if (Utils.isString(matches)) {
      matches = [matches];
    }

    return Utils.isArray(matches) ? matches : [];
  }


  /**
   * Register service handler delegate
   */
  function registerHandlerDelegate(plugin, service, handlerDelegate) {
    service.use({
      name    : plugin.name,
      match   : plugin._matches,
      handler : handlerDelegate
    });
  }


  /**
   * Creates handler for service to handle module meta objects
   */
  function createHandlerDelegate(plugin, serviceName) {
    return function handlerDelegate(moduleMeta) {
      if (!canExecute(plugin._matches, moduleMeta)) {
        return Promise.resolve();
      }

      // This is a nasty little sucker with nested layers of promises...
      // Handlers themselves can return promises and get injected into
      // the promise sequence.
      return plugin._handlers[serviceName].reduce(function(prev, curr) {
        return prev.then(function pluginHandler() {
          return curr.call(plugin, moduleMeta);
        }, Utils.reportError);
      }, Promise.resolve());
    };
  }


  /**
   * Function that goes through all the handlers and configures each one. This is
   * where handle things like if a handler is a string, then we assume it is the
   * name of a module that we need to load...
   */
  function configureHandlers(plugin, serviceName, handlers) {
    // Must provide handlers for the plugin's target
    if (!handlers) {
      throw new TypeError("Plugin must have 'handlers' defined");
    }

    if (Utils.isFunction(handlers)) {
      handlers = [handlers];
    }
    else if (Utils.isString(handlers)) {
      handlers = [handlers];
    }

    handlers = handlers.map(function(handler, i) {
      if (!handler || (!Utils.isString(handler) && !Utils.isFunction(handler))) {
        throw new TypeError("Plugin handler must be a string or a function");
      }

      if (Utils.isString(handler)) {
        var handlerName = handler;

        handler = function deferredHandlerDelegate() {
          var data = arguments;

          function handlerReady(newhandler) {
            // Naive approach to make sure we replace the proper handler
            if (handler === handlers[i]) {
              handlers[i] = newhandler;
              return newhandler.apply(plugin, data);
            }
            else {
              return Promise.reject(new TypeError("Unable to register '" + serviceName + ":" + handlerName + "'. The collection of handlers has mutated."));
            }
          }

          return deferredHandler(plugin, serviceName, handlerName).then(handlerReady, Utils.reportError);
        };
      }

      return handler;
    });

    return handlers;
  }


  /**
   * Create a handler delegate that when call, it loads a module to be used
   * as the actual handler used in a service.
   */
  function deferredHandler(plugin, serviceName, handlerName) {
    if (!plugin.settings.import) {
      throw new TypeError("You must configure an import method in order to dynamically load plugin handlers");
    }

    // Create a name that won't conflict with other deferred handlers in
    // the plugin.
    var deferredName = serviceName + ":" + handlerName;

    // Function that imports the service handler and makes sure to manage
    // caching to prevent multiple calls to import
    function importHandler() {
      if (!plugin._deferred[deferredName]) {
        logger.log("import [start]", deferredName, plugin);
        plugin._deferred[deferredName] = plugin.settings.import(handlerName);
      }
      else {
        logger.log("import [pending]", deferredName, plugin);
      }

      return plugin._deferred[deferredName];
    }

    // Callback when provider is loaded
    function handlerReady(handler) {
      if (plugin._deferred[deferredName]) {
        logger.log("import [end]", deferredName, plugin);
        delete plugin._deferred[deferredName];
      }

      return handler;
    }

    return importHandler().then(handlerReady, Utils.reportError);
  }


  /**
   * Checks if the handler can process the module meta object based on
   * the matching rules for path and name.
   */
  function canExecute(matches, moduleMeta) {
    var ruleLength, allLength = 0;

    if (matches) {
      for (var match in matches) {
        if (!matches.hasOwnProperty(match)) {
          continue;
        }

        ruleLength = matches[match].getLength();
        allLength += ruleLength;

        if (ruleLength && matches[match].match(moduleMeta[match])) {
          return true;
        }
      }
    }

    // If there was no matching rule, then we will return true.  That's because
    // if there weren't any rules put in place to restrict module processing,
    // then the assumption is that the module can be processed.
    return !allLength;
  }


  function createCanExecute(moduleMeta) {
    return function canExecuteDelegate(plugin) {
      if (plugin.match) {
        return canExecute(plugin.match, moduleMeta);
      }
      return true;
    };
  }


  Plugin.canExecute       = canExecute;
  Plugin.createCanExecute = createCanExecute;
  module.exports = Plugin;
}());

},{"./logger":18,"./rule-matcher":30,"./utils":32,"promise":10}],29:[function(require,module,exports){
(function() {
  "use strict";

  var StatefulItems = require('./stateful-items');
  var storage = {};


  /**
   * Module registry
   */
  function Registry(options) {
    options = options || {};
    this._id     = options.id || getRegistryId();
    this.modules = options.modules || new StatefulItems();
  }


  Registry.prototype.clear = function() {
    if (storage.hasOwnProperty(this._id)) {
      delete storage[this._id];
    }
    return this;
  };


  Registry.prototype.hasModule = function(name) {
    return this.modules.hasItem(name);
  };


  Registry.prototype.getModule = function(name) {
    return this.modules.getItem(name);
  };


  Registry.prototype.deleteModule = function(name) {
    return this.modules.removeItem(name);
  };


  Registry.prototype.setModule = function(state, name, item) {
    return this.modules.setItem(state, name, item);
  };


  Registry.prototype.getModuleState = function(name) {
    return this.modules.getState(name);
  };


  Registry.prototype.hasModuleWithState = function(state, name) {
    return this.modules.hasItemWithState(state, name);
  };


  Registry.prototype.getModuleWithState = function(state, name) {
    return this.modules.getItemWithState(state, name);
  };


  /**
   * Factory method that creates Registries with an id
   */
  Registry.getById = function(id) {
    if (!id) {
      id = getRegistryId();
    }

    return storage[id] || (storage[id] = new Registry({id: id}));
  };


  /**
   * Destroys Registries by id.
   */
  Registry.clearById = function(id) {
    if (storage.hasOwnProperty(id)) {
      return storage[id].clear();
    }
  };


  /**
   * Creates a named id generator you can use for prefixing generated ids. The
   * idea is that you can generate ids you prefix in order to group generated
   * ids.
   *
   * @param {string} name - Name of the id generator. Provide you to
   *   customize the ids generated. Defaults to 'generic'.
   * @parem {number} seed - Seed number to start id generation from.
   *
   * @returns {function} That when called creates and returns a new
   *   unique id.
   */
  Registry.idGenerator = function(name, seed) {
    name = (name || 'generic') + '-';
    var id = seed || 0;
    return function getId() {
      return name + id++;
    };
  };


  var getRegistryId = Registry.idGenerator();
  module.exports = Registry;
})();

},{"./stateful-items":31}],30:[function(require,module,exports){
(function() {
  "use strict";

  var Utils     = require('./utils');
  var minimatch = require('minimatch');


  /**
   * Rule is a convenience class for encapsulating a rule name and
   * the match criteria to test against.
   *
   * @param {Object} [options={}] - Settings for the rule to be created
   */
  function Rule(options) {
    options = options || {};
    this.settings = options;
    this._name    = Rule.configureName(options.name);
    this._match   = Rule.configureMatch(options.match);
  }


  var ruleId = 0;

  /**
   * Helper method to generate rule names.
   *
   * @returns {string} Name of the rule
   */
  Rule.configureName = function(name) {
    return name || ("rule-" + ruleId++);
  };


  /**
   * Helper method to make sure matches are an array
   *
   * @returns {Array.<string>} Array of matching string
   */
  Rule.configureMatch = function(match) {
    match = match || [];
    return !(match instanceof Array) ? [match] : match;
  };


  /**
   * Method that returns the name of the rule
   *
   * @returns {string} Name of the rule
   */
  Rule.prototype.getName = function() {
    return this._name;
  };


  /**
   * Method to add a match to the list of matches
   *
   * @param {string | Array.<string>} match - String or collection of strings to match
   *   against.
   */
  Rule.prototype.addMatch = function(match) {
    match = Rule.configureMatch(match);
    this._match = this._match.concat(match);
  };


  /**
   * Method to match only one rule
   *
   * @param {string} criteria - Input to test against.
   *
   * @returns {boolean} True if any rule is matched, false otherwise
   */
  Rule.prototype.matchOne = function(criteria) {
    var matches = this._match;
    var i, length;
    for (i = 0, length = matches.length; i < length; i++) {
      if (this.matchCriteria(criteria, matches[i])) {
        return true;
      }
    }
    return false;
  };


  /**
   * Method to test againt *all* rules
   *
   * @param {string} criteria - Input to test against
   *
   * @returns {boolean} True is *all* rules match, false otherwise
   */
  Rule.prototype.matchAll = function(criteria) {
    var matches = this._match;
    var i, length;
    for (i = 0, length = matches.length; i < length; i++) {
      if (!this.matchCriteria(criteria, matches[i])) {
        return false;
      }
    }
    return true;
  };


  /**
   * Function that runs the rule matching logic
   */
  Rule.prototype.matchCriteria = function(criteria, match) {
    // Minimatch it!
    return minimatch(criteria, match);
  };


  /**
   * Rule matching engine
   */
  function RuleMatcher(config) {
    if (!(this instanceof RuleMatcher)) {
      return new RuleMatcher(config);
    }

    this._rules = {};

    if (config) {
      this.add(config);
    }
  }


  RuleMatcher.configureRule = function(config) {
    if (Utils.isString(config)) {
      config = {
        name: config
      };
    }
    else if (Utils.isArray(config)) {
      config = {
        match: config
      };
    }
    return config;
  };


  RuleMatcher.prototype.add = function(config) {
    config = RuleMatcher.configureRule(config);

    var rule = this.find(config.name);
    if (rule) {
      rule.addMatch(config.match);
    }
    else {
      rule = new Rule(config);
      this._rules[rule.getName()] = rule;
    }

    return rule;
  };


  RuleMatcher.prototype.all = function() {
    return this._rules;
  };


  RuleMatcher.prototype.find = function(ruleName) {
    return this._rules[ruleName];
  };


  RuleMatcher.prototype.filter = function(ruleNames) {
    var rules = {};
    for (var name in ruleNames) {
      if (this.hasRule(ruleNames[name])) {
        rules[name] = this.find(name);
      }
    }
    return rules;
  };


  RuleMatcher.prototype.getLength = function() {
    return Object.keys(this._rules).length;
  };


  RuleMatcher.prototype.match = function(criteria, ruleNames) {
    return typeof ruleNames === "string" ?
      this.matchOne(criteria, ruleNames) :
      this.matchAny(criteria, ruleNames);
  };


  RuleMatcher.prototype.matchOne = function(criteria, ruleName) {
    // Make sure the rule exists
    if (!this.hasRule(ruleName)) {
      return false;
    }

    var rule = this.find(ruleName);
    return rule && rule.matchOne(criteria);
  };


  RuleMatcher.prototype.matchAny = function(criteria, filter) {
    var rules = filter ? this.filter(filter) : this._rules;
    for (var ruleName in rules) {
      if (rules[ruleName] && rules[ruleName].matchOne(criteria)) {
        return true;
      }
    }
    return false;
  };


  RuleMatcher.prototype.matchAll = function(criteria, filter) {
    var rules = filter ? this.filter(filter) : this._rules;
    for (var ruleName in rules) {
      if (rules[ruleName] && !rules[ruleName].matchOne(criteria)) {
        return false;
      }
    }
    return true;
  };


  RuleMatcher.prototype.hasRule = function(ruleName) {
    return this._rules.hasOwnProperty(ruleName);
  };


  RuleMatcher.prototype.ensureRule = function(ruleName) {
    if (!this.hasRule(ruleName)) {
      throw new TypeError("Rule '" + ruleName + "' was not found");
    }
    return true;
  };


  module.exports = RuleMatcher;
})();

},{"./utils":32,"minimatch":2}],31:[function(require,module,exports){
(function() {
  "use strict";

  function StatefulItems(items) {
    this.items = items || {};
  }


  /**
   * Helper methods for CRUD operations on `items` map for based on their StateTypes
   */


  StatefulItems.prototype.getState = function(name) {
    if (!this.hasItem(name)) {
      throw new TypeError("`" + name + "` not found");
    }

    return this.items[name].state;
  };


  StatefulItems.prototype.hasItemWithState = function(state, name) {
    return this.hasItem(name) && this.items[name].state === state;
  };


  StatefulItems.prototype.getItemWithState = function(state, name) {
    if (!this.hasItemWithState(state, name)) {
      throw new TypeError("`" + name + "` is not " + state);
    }

    return this.items[name].item;
  };


  StatefulItems.prototype.hasItem = function(name) {
    return this.items.hasOwnProperty(name);
  };


  StatefulItems.prototype.getItem = function(name) {
    if (!this.hasItem(name)) {
      throw new TypeError("`" + name + "` not found");
    }

    return this.items[name].item;
  };


  StatefulItems.prototype.removeItem = function(name) {
    if (!this.items.hasOwnProperty(name)) {
      throw new TypeError("`" + name + "` cannot be removed - not found");
    }

    var item = this.items[name];
    delete this.items[name];
    return item.item;
  };


  StatefulItems.prototype.setItem = function(state, name, item) {
    return (this.items[name] = {item: item, state: state}).item;
  };


  module.exports = StatefulItems;
})();

},{}],32:[function(require,module,exports){
(function() {
  "use strict";

  function noop() {
  }

  function isNull(item) {
    return item === null || item === (void 0);
  }

  function isArray(item) {
    return item instanceof(Array);
  }

  function isString(item) {
    return typeof(item) === "string";
  }

  function isObject(item) {
    return typeof(item) === "object";
  }

  function isPlainObject(item) {
    return !!item && !isArray(item) && (item.toString() === "[object Object]");
  }

  function isFunction(item) {
    return !isNull(item) && item.constructor === Function;
  }

  function isDate(item) {
    return item instanceof(Date);
  }

  function result(input, args, context) {
    if (isFunction(input) === "function") {
      return input.apply(context, args||[]);
    }
    return input[args];
  }

  function toArray(items) {
    if (isArray(items)) {
      return items;
    }

    return Object.keys(items).map(function(item) {
      return items[item];
    });
  }

  /**
   * Copies all properties from sources into target
   */
  function extend(target) {
    var source, length, i;
    var sources = Array.prototype.slice.call(arguments, 1);
    target = target || {};

    // Allow n params to be passed in to extend this object
    for (i = 0, length  = sources.length; i < length; i++) {
      source = sources[i];
      for (var property in source) {
        if (source.hasOwnProperty(property)) {
          target[property] = source[property];
        }
      }
    }

    return target;
  }

  /**
   * Deep copy of all properties insrouces into target
   */
  function merge(target) {
    var source, length, i;
    var sources = Array.prototype.slice.call(arguments, 1);
    target = target || {};

    // Allow `n` params to be passed in to extend this object
    for (i = 0, length  = sources.length; i < length; i++) {
      source = sources[i];
      for (var property in source) {
        if (source.hasOwnProperty(property)) {
          if (isPlainObject(source[property])) {
            target[property] = merge(target[property], source[property]);
          }
          else {
            target[property] = source[property];
          }
        }
      }
    }

    return target;
  }


  function printError(error) {
    if (error && !error.handled) {
      error.handled = true;
      if (error.stack) {
        console.log(error.stack);
      }
      else {
        console.error(error);
      }
    }

    return error;
  }


  function forwardError(error) {
    return error;
  }


  function notImplemented() {
    throw new TypeError("Not implemented");
  }


  module.exports = {
    isNull: isNull,
    isArray: isArray,
    isString: isString,
    isObject: isObject,
    isPlainObject: isPlainObject,
    isFunction: isFunction,
    isDate: isDate,
    toArray: toArray,
    noop: noop,
    result: result,
    extend: extend,
    merge: merge,
    printError: printError,
    forwardError: forwardError,
    notImplemented: notImplemented
  };
})();

},{}]},{},[12])(12)
});