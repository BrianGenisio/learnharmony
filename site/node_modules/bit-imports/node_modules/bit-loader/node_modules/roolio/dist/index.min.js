/*! roolio v0.1.0 - 2015-06-20. (c) 2015 Miguel Castillo. Licensed under MIT */
!function(a){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=a();else if("function"==typeof define&&define.amd)define([],a);else{var b;b="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this,b.roolio=a()}}(function(){return function a(b,c,d){function e(g,h){if(!c[g]){if(!b[g]){var i="function"==typeof require&&require;if(!h&&i)return i(g,!0);if(f)return f(g,!0);var j=new Error("Cannot find module '"+g+"'");throw j.code="MODULE_NOT_FOUND",j}var k=c[g]={exports:{}};b[g][0].call(k.exports,function(a){var c=b[g][1][a];return e(c?c:a)},k,k.exports,a,b,c,d)}return c[g].exports}for(var f="function"==typeof require&&require,g=0;g<d.length;g++)e(d[g]);return e}({1:[function(a,b,c){function d(a){a=a||{},this._name=d.configureName(a.name),this._match=d.configureMatch(a.match)}var e=a("./matcher"),f=0;d.configureName=function(a){return a||"rule-"+f++},d.configureMatch=function(a){return a=a||[],a=a instanceof Array?a:[a],a.map(function(a){return a&&a.constructor===Function?a:e(a)})},d.prototype.getName=function(){return this._name},d.prototype.getLength=function(){return this._match.length},d.prototype.addMatcher=function(a){return this._match=this._match.concat(d.configureMatch(a)),this},d.prototype.match=d.prototype.matchAny=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(d.__match(e[b],a))return!0;return!1},d.prototype.matchAll=function(a){var b,c,e=this._match;for(b=0,c=e.length;c>b;b++)if(!d.__match(e[b],a))return!1;return!0},d.__match=function(a,b){try{return a(b)}catch(c){}return!1},d.matcher=e,b.exports=d},{"./matcher":2}],2:[function(a,b,c){function d(a){return a instanceof RegExp?function(b){return a.test(b)}:function(b){return b===a}}d.extension=function(a){if(""===a||"string"!=typeof a)throw new TypeError("Matching rule must be a string");return a=new RegExp("\\.("+a+")$"),function(b){return a.test(b)}},d.string=function(a){if("string"!=typeof a)throw new TypeError("Match type must be a string");return function(b){return a===b}},d.regex=function(a){if(""!==a&&"string"==typeof a&&(a=new RegExp(a)),!(a instanceof RegExp))throw new TypeError("Match type must be a string or a regex");return function(b){return a.test(b)}},b.exports=d},{}]},{},[1])(1)});
//# sourceMappingURL=index.min.js.map