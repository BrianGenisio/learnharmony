{
  "name": "spromise",
  "version": "0.9.1",
  "license": "MIT",
  "main": "dist/spromise.js",
  "author": {
    "name": "Miguel Castillo",
    "email": "manchagnu@gmail.com"
  },
  "contributors": [
    {
      "name": "Mark Simulacrum",
      "email": "mark.simulacrum@gmail.com",
      "url": "https://github.com/Mark-Simulacrum"
    }
  ],
  "title": "spromise",
  "description": "Small Promise",
  "keywords": [
    "promise",
    "a plus",
    "a+ promise",
    "jquery promise",
    "$ promise",
    "defer",
    "deferred",
    "thenable",
    "then"
  ],
  "homepage": "https://github.com/MiguelCastillo/spromise",
  "repository": {
    "type": "git",
    "url": "http://github.com/MiguelCastillo/spromise.git"
  },
  "bugs": {
    "url": "https://github.com/MiguelCastillo/spromise/issues",
    "email": "manchagnu@gmail.com"
  },
  "devDependencies": {
    "bower": "^1.3.12",
    "grunt": "~0.4.1",
    "grunt-cli": "~0.1.13",
    "grunt-contrib-connect": "~0.8.0",
    "grunt-contrib-jshint": "^0.10.0",
    "grunt-contrib-requirejs": "~0.4.1",
    "grunt-mocha": "~0.4.11",
    "jshint-stylish": "^1.0.0",
    "promises-aplus-tests": ""
  },
  "scripts": {
    "prepublish": "bower install && grunt build --verbose",
    "test": "grunt lint && node tests/promises-aplus-tests.js && grunt test"
  },
  "directories": {
    "test": "tests"
  },
  "readme": "spromise [![Build Status](https://travis-ci.org/MiguelCastillo/spromise.png?branch=master)](https://travis-ci.org/MiguelCastillo/spromise)\n=========\n\nspromise (Small Promise), is an implementation of the promise <a href=\"https://promisesaplus.com/\">A+ spec</a>.  It is designed to be lightweight, performant, and per spec, interoperable with other promise implementations such as jQuery's <a href=\"http://api.jquery.com/category/deferred-object/\">deferred</a>.\n\n## Table of Contents\n\n* [API](#api)\n  * [Static methods](#static-methods)\n    * [spromise as a constructor](#spromise-as-a-constructor)\n    * [spromise.defer](#spromisedefer)\n    * [spromise.resolve](#spromiseresolve)\n    * [spromise.reject](#spromisereject)\n    * [spromise.when](#spromisewhen)\n    * [spromise.all](#spromiseall)\n  * [Instance methods](#instance-methods)\n    * [then](#then)\n    * [done](#done)\n    * [fail and catch](#fail-and-catch)\n    * [always](#always)\n    * [resolve](#resolve)\n    * [reject](#reject)\n    * [delay](#delay)\n    * [state](#state)\n    * [isPending](#ispending)\n    * [isResolved](#isresolved)\n    * [isRejected](#isrejected)\n  * [Instance Properties](#instance-properties)\n    * [promise](#promise)\n* [Install](#install)\n    * [bower](#bower)\n    * [npm](#npm)\n* [Downloads](#downloads)\n* [Build](#build)\n* [Tests](#tests)\n    * [Unit tests](#unit-tests)\n    * [Compliance unit tests:](#compliance-unit-tests)\n* [Compliance notes](#compliance-notes)\n\n\n## API\n\n### Static methods\n\n#### spromise as a constructor\nCreates a promise instance.  It can take in a function as its single optional parameter, which is called when the promise is created.  The callback function receives two parameters, a function to fulfill the promise and a function to reject the promise.\n\nResolve a promise\n``` javascript\n// Resolve\nspromise(function(resolve, reject){\n  resolve(\"Yes, we are resolving this\");\n})\n.done(function(value) {\n  // Will print \"Yes, we are resolving this\"\n  console.log(value);\n});\n```\n\nReject a promise\n``` javascript\n// Reject\nspromise(function(resolve, reject){\n  reject(\"booo\");\n})\n.fail(function(value) {\n  // Will print \"booo\"\n  console.log(value);\n});\n```\n\n#### spromise.defer\nCreates and returns a new promise to be resolved in the future.\n\n- returns a `new` promise\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Create a deferred promise\nvar promise = spromise.defer();\n\npromise.done(function(data) {\n  console.log(data);\n});\n\npromise.resolve(\"Deferred\");\n```\n\n#### spromise.resolve\nReturns a promise instance.  If the input is an instance of spromise, then that's returned as is. If the input is a thenable object or function, a new promise is returned with the current/future value of the thenable. And if the value is anything else, then a new promise that is already fulfilled with the value(s) is returned.\n\n- returns a promise\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.resolve(\"Resolved promise\");\n\npromise.done(function(data) {\n  console.log(data);\n});\n```\n\n#### spromise.reject\nReturns a new promise that is rejected with the reason passed in. The reason can be any data type.\n\n- returns a `new` rejected promise\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.reject(\"Rejected promise\");\n\npromise.fail(function(data) {\n  console.log(data);\n});\n```\n\n#### spromise.when\ncreates and returns a promise. <code>when</code> takes in N arguments that control when the <code>when</code> promise is resolved.  Passing in promises as arguments will cause <code>when</code> to wait for all the input promises to resolve.  If one fails, everything fails.  None promise objects can also be passed in, in which case they are immediately resolved.  <code>when</code> is very useful when synchronizing a group of asynchronous and synchronous operations.\n\n- returns a `new` promise\n\n<p>Synchronizing multiple $.ajax request</p>\n``` javascript\nspromise.when($.ajax(\"json/array.json\"), $.ajax(\"json/object.json\")).done(function($array, $object) {\n  // Will print the XHR objects $array and $object\n  console.log($array, $object);\n});\n```\n\n#### spromise.all\nsimilar to `when` except that the input parameters are in the form of a single array.\n\n- returns a `new` promise\n\n<p>Synchronizing multiple $.ajax request</p>\n``` javascript\nspromise.all([$.ajax(\"json/array.json\"), $.ajax(\"json/object.json\")]).done(function(result) {\n  // Will print the XHR objects $array and $object\n  var $array  = result[0],\n      $object = result[1];\n  console.log($array, $object);\n});\n```\n\n### Instance methods\n\n#### then\nmethod to register callbacks to be called when the promise is fulfilled or rejected.  The first parameter is the callback to be called when the promise is fulfilled, and the second parameter is the callback to be called when the promise is rejected.\n\nThis method is generally used for creating chains of promises.  If calling fulfilled or rejected returns anything, then that value is returned to the subsequent promise in a thenable chain.  See examples in the Examples section.\n\n- returns a `new` promise\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Fulfilled promise\nvar promise = spromise.resolve(\"Fulfilled promise\");\n\n// Register callbacks\npromise.then(resolved, rejected);\n\nfunction resolved(data) {\n  console.log(err);\n}\n\nfunction rejected(err) {\n  // Does not get called because the promise was fulfilled.\n}\n```\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Reject promise\nvar promise = spromise.reject(\"Rejected promise\");\n\n// Register callbacks\npromise.then(resolved, rejected);\n\nfunction resolved(data) {\n  // Does not get called because the promise was rejected.\n}\n\nfunction rejected(err) {\n  console.log(err);\n}\n```\n\n#### done\nmethod takes a callback as its only parameter that gets called when the promise is fulfilled. If the promise is fulfilled with a value(s), that value will get passed in as parameter(s) to the callback.\n\n- returns promise (itself)\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.resolve(\"Resolved promise\", \"extra value\");\n\npromise.done(function(data1, data2) {\n  console.log(data1, data2);\n});\n```\n\n#### fail and catch\nmethod takes a callback as its only parameter that gets called when the promise is rejected. If the promise is rejected with a reason(s), that will then get passed in as parameter(s) to the callback.\n\n- Note: fail and catch are exactly the same methods, and they both exist to provide alternatives for folks used to one vs the other.\n\n- returns promise (itself)\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.reject(\"Reason...\");\n\npromise.fail(function(reason) {\n  console.log(reason);\n});\n\npromise.catch(function(reason) {\n  console.log(reason);\n});\n```\n\n#### always\nmethod to register a callback that gets called when the promise is either fulfilled or rejected.\n\n- returns promise (itself)\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.resolve(\"Fulfilled promise\");\n\npromise.always(function(data) {\n  console.log(data);\n});\n```\n\n``` javascript\nvar spromise = require(\"spromise\");\nvar promise = spromise.reject(\"Reason...\");\n\npromise.always(function(reason) {\n  console.log(reason);\n});\n```\n\n#### resolve\nmethod to fulfill the promise. This will cause all registered callbacks (current as well as future ones) to be called with the resolved value.\n\n- returns promise (itself)\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Create a deferred promise\nvar promise = spromise.defer();\n\npromise.done(function(data) {\n  console.log(data);\n});\n\npromise.resolve(\"Deferred\");\n```\n\n#### reject\nmethod to reject the promise. This will cause all registered callbacks (current as well as future ones) to be called with the reason for rejecting the promise.\n\n- returns promise (itself)\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Create a deferred promise\nvar promise = spromise.defer();\n\npromise.fail(function(data) {\n  console.log(data);\n});\n\npromise.reject(\"Deferred\");\n```\n\n#### delay\nmethod that will delay the resolution of a promise chain by the amount of MilliSeconds passed in as its only parameter.\n\n- returns `new` promise.\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Create a deferred promise\nvar promise = spromise.defer();\n\npromise.delay(3000).done(function(data) {\n  console.log(\"3 seconds later\", data);\n});\n\npromise.resolve(\"Deferred\");\n```\n\n#### state\nmethod to get the current state of the promise.  The values can be `\"pending\"`, `\"resolved\"`, or `\"rejected\"`.\n\n- returns string\n\n\n#### isPending\nmethod that returns whether or not the promise is in a pending state; meaning is has not yet been resolved.\n\n- returns boolean\n\n#### isResolved\nmethod that returns whether or not the promise has been successfully resolved.\n\n- returns boolean\n\n#### isRejected\nmethod that returns whether or not the promise has been rejected.\n\n- returns boolean\n\n\n### Instance Properties\n\n#### promise\nproperty that contains methods to read the value and status of the promise.  This is useful if you want to create a promise and return the read only version of it.  The methods in this object are `then`, `always`, `done`, `catch`, `fail`, `notify`, `state`.\n\n\n``` javascript\nvar spromise = require(\"spromise\");\n\n// Create a deferred promise\nvar promise = spromise.defer();\n\n// Print out the promise property\nconsole.log(promise.promise);\n```\n\n\n## Install\n\n#### bower\n\n```\n$ bower install spromise\n```\n\n#### npm\n\n```\n$ npm install spromise\n```\n\n## Downloads\n\nGeneral purpose UMD (Browser, Node):\n* [spromise.js](https://github.com/MiguelCastillo/spromise/releases/download/v0.8.1/spromise.js) - minified\n* [spromise-debug.js](https://github.com/MiguelCastillo/spromise/releases/download/v0.8.1/spromise-debug.js)\n\nFor inline inclusion in your AMD code:\n* [spromise-lib.js](https://github.com/MiguelCastillo/spromise/releases/download/v0.8.1/spromise-lib.js) - minified\n* [spromise-lib-debug.js](https://github.com/MiguelCastillo/spromise/releases/download/v0.8.1/spromise-lib-debug.js)\n\n## Build\n\nRun the following command in the terminal:\n\n```\n$ npm install\n```\n\n## Tests\n\n#### Unit tests\n\nRun the following commands in the terminal:\n\n```\n$ npm install\n$ grunt test\n```\n\n#### Compliance unit tests:\n\nRun the following commands in the terminal:\n```\n$ npm install\n$ npm test\n```\n\n## Compliance notes\n\nWith the exception of 2.2.5, which states that onFullfilled/onRejected must not be called with \"this\", all tests for compliance pass.<br>\nThe reason spromise was left non compliant for this particular item is to faithfully handle \"context\" configured in jQuery ajax requests.\n\n* NOTE: The spec makes use of `fulfilled`, which is the exact same thing as `resolved` in spromise. The different names exists because it seems more consistent that if you call `resolve` to transition a promise to the `resolved` state, that the state is `resolved` and not `fulfilled`.  In spromise's documention both are used simply for better readability.\n\n##### Test results:\n\n<pre>\n  868 passing (14s)\n  4 failing\n\n  1) 2.2.5 `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value). strict mode fulfilled:\n     Error: timeout of 200ms exceeded\n      at null.<anonymous> (/Users/mcastillo/Projects/promises-tests/node_modules/mocha/lib/runnable.js:165:14)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  2) 2.2.5 `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value). strict mode rejected:\n     Error: timeout of 200ms exceeded\n      at null.<anonymous> (/Users/mcastillo/Projects/promises-tests/node_modules/mocha/lib/runnable.js:165:14)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  3) 2.2.5 `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value). sloppy mode fulfilled:\n     Error: timeout of 200ms exceeded\n      at null.<anonymous> (/Users/mcastillo/Projects/promises-tests/node_modules/mocha/lib/runnable.js:165:14)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n\n  4) 2.2.5 `onFulfilled` and `onRejected` must be called as functions (i.e. with no `this` value). sloppy mode rejected:\n     Error: timeout of 200ms exceeded\n      at null.<anonymous> (/Users/mcastillo/Projects/promises-tests/node_modules/mocha/lib/runnable.js:165:14)\n      at Timer.listOnTimeout [as ontimeout] (timers.js:110:15)\n</pre>\n",
  "readmeFilename": "README.md",
  "_id": "spromise@0.9.1",
  "_from": "spromise@~0.9.1"
}
