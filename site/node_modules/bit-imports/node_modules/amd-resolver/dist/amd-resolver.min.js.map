{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/resolver.js","src/file.js","src/url.js","node_modules/browserify/node_modules/path-browserify/index.js"],"names":["Resolver","options","this","settings","baseUrl","length","File","require","Url","prototype","resolve","name","i","file","pkg","pkgParts","pkgName","pkgTarget","shim","urlArgs","shims","packages","paths","fileName","plugins","split","pop","replace","shift","join","location","main","hasOwnProperty","exports","deps","imports","test","useBase","url","hasProtocol","module","fileUrl","parseParts","fileString","directory","match","path","addExtension","extension","fileParts","push","replaceExtension","regex","urlString","baseString","parser","href","base","parse","pathname","isAbsolute","hostname","urlParts","exec","normalize","origin","protocol","delimeter","username","password","port","search","hash","host","substr","lastIndexOf","normalizeArray","parts","allowAboveRoot","up","last","splice","unshift","filter","xs","f","res","splitPathRe","splitPath","filename","slice","resolvedPath","resolvedAbsolute","arguments","process","cwd","TypeError","charAt","p","trailingSlash","Array","call","index","relative","from","to","trim","arr","start","end","fromParts","toParts","Math","min","samePartsLength","outputParts","concat","sep","delimiter","dirname","result","root","dir","basename","ext","extname","str","len"],"mappings":"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","file":"bundle.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","var File = require('./file');\nvar Url  = require('./url');\n\n/**\n * @constructor\n * Provides a way to build a module meta object from a module name.  The resolution\n * relies on configuration settings, which are compatible with requirejs. The created\n * module meta objects contain information such as a url that can be used for downloading\n * the corresponding file from a remote sever.\n */\nfunction Resolver(options) {\n  this.settings = options || {};\n  var baseUrl = this.settings.baseUrl || (this.settings.baseUrl = \".\");\n\n  // Make sure that if a baseUrl is provided, it ends in a slash.  This is to ensure\n  // proper creation of URLs.\n  if (baseUrl && baseUrl[baseUrl.length - 1] !== '/') {\n    this.settings.baseUrl = baseUrl + '/';\n  }\n}\n\n/**\n * Creates a module meta from a module name/id.\n *\n * @param {string} name - Module name/id\n * @param {string} baseUrl - base url to be used when the `name` starts with `./`, `../`, or a protocol.\n *   Otherwise the configured baseUrl is used.\n *\n * @returns {{name: string, file: File, urlArgs: string, shim: object}}\n */\nResolver.prototype.resolve = function(name, baseUrl) {\n  var i, length, file, pkg, pkgParts, pkgName, pkgTarget, shim;\n  var settings = this.settings,\n      urlArgs  = settings.urlArgs,\n      shims    = settings.shim || {},\n      packages = settings.packages || [],\n      paths    = settings.paths || {},\n      fileName = paths[name],\n      plugins  = name.split(\"!\");\n\n  // The last item is the actual module name.\n  name      = plugins.pop();\n  pkgParts  = name.replace(/[\\/\\\\]+/g, \"/\").split(\"/\");\n  pkgName   = pkgParts.shift();\n  pkgTarget = pkgParts.join(\"/\");\n\n  // Go through the packages and figure if the module is actually configured as such.\n  for (i = 0, length = packages.length; i < length; i++) {\n    pkg = packages[i];\n\n    if (pkg === pkgName) {\n      fileName = pkgName + \"/\" + \"main\";\n      break;\n    }\n    else if (pkg.name === pkgName) {\n      fileName = pkg.location ? (pkg.location + \"/\") : \"\";\n      fileName += pkgName + \"/\" + (pkgTarget || (pkg.main || \"main\"));\n      break;\n    }\n  }\n\n  if (shims.hasOwnProperty(name)) {\n    shim = {\n      name: shims[name].exports || shims[name].name || name,\n      deps: shims[name].imports || shims[name].deps || []\n    };\n  }\n\n  if (!fileName) {\n     fileName = name;\n  }\n\n  // Let's assume .js extension for everything that is not defined with plugins\n  if (plugins.length === 0 && /\\.js$/.test(fileName) === false) {\n    fileName += \".js\";\n  }\n\n  baseUrl = Resolver.useBase(fileName) && baseUrl ? baseUrl : settings.baseUrl;\n  file    = new File(urlArgs ? fileName + \"?\" + urlArgs : fileName, baseUrl);\n\n  return {\n    name: name,\n    file: file, // Deprecated in favor of `url`\n    url: file.url,\n    shim: shim,\n    plugins: plugins\n  };\n};\n\n\n/**\n * Checks and returns true if name starts with `./`, `../`, or a protocol.  Otherwise returns false;\n */\nResolver.useBase = function(name) {\n  return (name[0] === '.' && (name[1] === '/' || (name[1] === '.' && name[2] === '/'))) || Resolver.hasProtocol(name);\n};\n\n\n/**\n * Quick check to determine if the name has a known protocol. Currently we only support http(s) and file.\n */\nResolver.hasProtocol = function(name) {\n  return /^(?:(https?|file)(:\\/\\/\\/?))/g.test(name);\n};\n\n\nResolver.File  = File;\nResolver.Url   = Url;\nmodule.exports = Resolver;\n","var Url = require('./url');\n\nfunction File(fileUrl, baseUrl) {\n  this.url = new Url(fileUrl, baseUrl);\n}\n\n/**\n * Build and file object with the important pieces\n */\nFile.parseParts = function (fileString) {\n  var name;\n  var directory = fileString.replace(/([^/]+)$/gmi, function(match) {name = match;return \"\";});\n\n  return {\n    name: name || \"\",\n    directory: directory,\n    path: fileString\n  };\n};\n\n/**\n * Method to add an extension if one does not exist in the fileString.  It does NOT replace\n * the file extension if one already exists in `fileString`.\n *\n * @param {string} fileString - File string to add the extension to if one does not exist\n * @param {string} extension - Extension to add if one does not exist in `fileString`. The\n *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.\n * @returns {string} New fileString with the new extension if one did not exist\n */\nFile.addExtension = function(fileString, extension) {\n  var fileName  = File.parseParts(fileString),\n      fileParts = fileName.name.split(\".\");\n\n  if (fileParts.length === 1 && extension) {\n    fileParts.push(extension);\n  }\n\n  return fileName.directory + fileParts.join(\".\");\n};\n\n/**\n * Method to replace an extension, if one does not exist in the file string, it will be added.\n *\n * @param {string} fileString - File string to add the extension to if one does not exist\n * @param {string} extension - Extension to be either added to `fileString` or to replace the extension in `fileString`. The\n *   value is the extension without the `.`. E.g. `js`, `html`.  Not `.js`, `.html`.\n * @returns {string} fileString with the new extension\n */\nFile.replaceExtension = function(fileString, extension) {\n  var regex = /([^.\\/\\\\]+\\.)[^.]+$/;\n  if (fileString.match(regex)) {\n    return fileString.replace(regex, \"$1\" + extension);\n  }\n  else {\n    return fileString + \".\" + extension;\n  }\n};\n\nmodule.exports = File;\n","var path = require('path');\n\n/**\n * Url factory that creates URL object as defined here https://developer.mozilla.org/en-US/docs/Web/API/URL\n *\n * @param {urlString} string - URL string to build a URL object from\n * @param {baseString} string - URL string to use as a base for building the URL object.\n *\n * @returns {object} URL object\n */\nfunction Url(urlString, baseString) {\n  return Url.parser.join(baseString || \"\", urlString);\n}\n\n\n/**\n * Parses out a url, with an optional base url, and returns the fully processed href.\n *\n * @param {string} urlString - URL to be processed\n * @param {string} baseString - Base URL\n *\n * @returns {string} full href\n */\nfunction resolve(baseString, urlString) {\n  return Url.parser.join(baseString, urlString).href;\n}\n\n\n/**\n * Parses out a url string with an optional base url, and returns the fully resolved URL object.\n *\n * @param {string} urlString - URL to be processed\n * @param {string} baseString - Base URL\n *\n * @returns {object} URL object\n */\nfunction join(baseString, urlString) {\n  var base     = parse(baseString);\n  var url      = parse(urlString);\n  var pathname = \"\";\n\n  if (path.isAbsolute(url.pathname)) {\n    pathname = url.pathname;\n  }\n  else if (base.pathname || url.pathname) {\n    pathname = path.join(directory(base.pathname), url.pathname);\n  }\n\n  if (!url.hostname && base.hostname) {\n    url = base;\n  }\n\n  url.pathname = pathname;\n  url.href     = parse.href(url);\n  return url;\n}\n\n\n/**\n * Parses out a string and creates a URL object as defined\n * here https://developer.mozilla.org/en-US/docs/Web/API/URL\n *\n * Parses out the username and password from a URL as defined here.\n * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/username\n * https://developer.mozilla.org/en-US/docs/Web/API/URLUtils/password\n *\n * @param {string} urlString - URL string to be parsed to create a URL object\n * @returns {object} URL object\n */\nfunction parse(urlString) {\n  var urlParts = /^((https?:)(\\/\\/\\/?)(?:([\\w]+)(?::([\\w]*))?@)?([\\d\\w\\.-]+)(?::(\\d+))?)?([\\/\\\\\\w\\.()-]*)?(?:([?][^#]*)?(#.*)?)*/gmi.exec(urlString);\n  urlParts.shift();\n\n  // Make sure we sanitize the slashes and dotted paths\n  if (urlParts[5]) {\n    urlParts[5] = path.normalize(urlParts[5]);\n  }\n\n  var url = {\n    origin    : urlParts[0] || \"\",\n    protocol  : urlParts[1] || \"\",\n    delimeter : urlParts[2] || \"\",\n    username  : urlParts[3] || \"\",\n    password  : urlParts[4] || \"\",\n    hostname  : urlParts[5] || \"\",\n    port      : urlParts[6] || \"\",\n    pathname  : urlParts[7] || \"\",\n    search    : urlParts[8] || \"\",\n    hash      : urlParts[9] || \"\"\n  };\n\n  url.pathname = parse.pathname(url);\n  url.host     = parse.host(url);\n  url.href     = parse.href(url);\n  return url;\n}\n\n\n/**\n * Parses out the pathname based on whether or not a hostname exists. If a\n * hostname exists then there must always be a path; \"/\" by default. Otherwise\n * pathname can be empty.\n *\n * @param {object} url - URL object\n * @returns {string} pathname\n */\nparse.pathname = function(url) {\n  return url.hostname ? (url.pathname || \"/\") : url.pathname;\n};\n\n\n/**\n * Builds a host string.  The host string is defined as the hostname, and if a port\n * is specified, then a \":\" and the port number.  Otherwise just the hostname.\n *\n * @param {object} url - URL object\n * @returns {string} Host string\n */\nparse.host = function(url) {\n  return url.hostname + (url.port ? \":\" + url.port : \"\");\n};\n\n\n/**\n * Builds the full URL as a string\n *\n * @param {object} url - URL object\n * @returns {string} Full url as a string\n */\nparse.href = function(url) {\n  return url.origin + url.pathname + url.search + url.hash;\n};\n\n\n/**\n * Processes a pathname and returns only the path. If a file is present\n * then it is removed, otherwise the same string is returned.\n *\n * @returns {string} directory of the pathname\n */\nfunction directory(pathname) {\n  return (pathname.length !== 1 && pathname[pathname.length - 1] !== \"/\") ?\n    pathname.substr(0, pathname.lastIndexOf(\"/\")) :\n    pathname;\n}\n\n\nUrl.parser = {\n  resolve : resolve,\n  parse   : parse,\n  join    : join\n};\n\n\n//\n// This chunk of code below enables nodejs URL module.  Useful for testing purposes.\n//\n//Url.parser = require('url');\n//Url.parser.join = function(baseString, urlString) {\n//  var resolved = Url.parser.resolve(baseString || \"\", urlString);\n//  var url      = Url.parser.parse(resolved);\n//  url.origin   = url.protocol ? (url.protocol + \"//\" + url.host) : \"\";\n//  url.hash     = url.hash     || \"\";\n//  url.host     = url.host     || \"\";\n//  url.hostname = url.hostname || \"\";\n//  url.password = url.password || \"\";\n//  url.pathname = url.pathname || \"\";\n//  url.port     = url.port     || \"\";\n//  url.protocol = url.protocol || \"\";\n//  url.search   = url.search   || \"\";\n//  url.username = url.username || \"\";\n//  return url;\n//};\n\n\nmodule.exports = Url;\n","// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// resolves . and .. elements in a path array with directory names there\n// must be no slashes, empty elements, or device names (c:\\) in the array\n// (so also no leading and trailing slashes - it does not distinguish\n// relative and absolute paths)\nfunction normalizeArray(parts, allowAboveRoot) {\n  // if the path tries to go above the root, `up` ends up > 0\n  var up = 0;\n  for (var i = parts.length - 1; i >= 0; i--) {\n    var last = parts[i];\n    if (last === '.') {\n      parts.splice(i, 1);\n    } else if (last === '..') {\n      parts.splice(i, 1);\n      up++;\n    } else if (up) {\n      parts.splice(i, 1);\n      up--;\n    }\n  }\n\n  // if the path is allowed to go above the root, restore leading ..s\n  if (allowAboveRoot) {\n    for (; up--; up) {\n      parts.unshift('..');\n    }\n  }\n\n  return parts;\n}\n\n// Split a filename into [root, dir, basename, ext], unix version\n// 'root' is just a slash, or nothing.\nvar splitPathRe =\n    /^(\\/?|)([\\s\\S]*?)((?:\\.{1,2}|[^\\/]+?|)(\\.[^.\\/]*|))(?:[\\/]*)$/;\nvar splitPath = function(filename) {\n  return splitPathRe.exec(filename).slice(1);\n};\n\n// path.resolve([from ...], to)\n// posix version\nexports.resolve = function() {\n  var resolvedPath = '',\n      resolvedAbsolute = false;\n\n  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {\n    var path = (i >= 0) ? arguments[i] : process.cwd();\n\n    // Skip empty and invalid entries\n    if (typeof path !== 'string') {\n      throw new TypeError('Arguments to path.resolve must be strings');\n    } else if (!path) {\n      continue;\n    }\n\n    resolvedPath = path + '/' + resolvedPath;\n    resolvedAbsolute = path.charAt(0) === '/';\n  }\n\n  // At this point the path should be resolved to a full absolute path, but\n  // handle relative paths to be safe (might happen when process.cwd() fails)\n\n  // Normalize the path\n  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {\n    return !!p;\n  }), !resolvedAbsolute).join('/');\n\n  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';\n};\n\n// path.normalize(path)\n// posix version\nexports.normalize = function(path) {\n  var isAbsolute = exports.isAbsolute(path),\n      trailingSlash = substr(path, -1) === '/';\n\n  // Normalize the path\n  path = normalizeArray(filter(path.split('/'), function(p) {\n    return !!p;\n  }), !isAbsolute).join('/');\n\n  if (!path && !isAbsolute) {\n    path = '.';\n  }\n  if (path && trailingSlash) {\n    path += '/';\n  }\n\n  return (isAbsolute ? '/' : '') + path;\n};\n\n// posix version\nexports.isAbsolute = function(path) {\n  return path.charAt(0) === '/';\n};\n\n// posix version\nexports.join = function() {\n  var paths = Array.prototype.slice.call(arguments, 0);\n  return exports.normalize(filter(paths, function(p, index) {\n    if (typeof p !== 'string') {\n      throw new TypeError('Arguments to path.join must be strings');\n    }\n    return p;\n  }).join('/'));\n};\n\n\n// path.relative(from, to)\n// posix version\nexports.relative = function(from, to) {\n  from = exports.resolve(from).substr(1);\n  to = exports.resolve(to).substr(1);\n\n  function trim(arr) {\n    var start = 0;\n    for (; start < arr.length; start++) {\n      if (arr[start] !== '') break;\n    }\n\n    var end = arr.length - 1;\n    for (; end >= 0; end--) {\n      if (arr[end] !== '') break;\n    }\n\n    if (start > end) return [];\n    return arr.slice(start, end - start + 1);\n  }\n\n  var fromParts = trim(from.split('/'));\n  var toParts = trim(to.split('/'));\n\n  var length = Math.min(fromParts.length, toParts.length);\n  var samePartsLength = length;\n  for (var i = 0; i < length; i++) {\n    if (fromParts[i] !== toParts[i]) {\n      samePartsLength = i;\n      break;\n    }\n  }\n\n  var outputParts = [];\n  for (var i = samePartsLength; i < fromParts.length; i++) {\n    outputParts.push('..');\n  }\n\n  outputParts = outputParts.concat(toParts.slice(samePartsLength));\n\n  return outputParts.join('/');\n};\n\nexports.sep = '/';\nexports.delimiter = ':';\n\nexports.dirname = function(path) {\n  var result = splitPath(path),\n      root = result[0],\n      dir = result[1];\n\n  if (!root && !dir) {\n    // No dirname whatsoever\n    return '.';\n  }\n\n  if (dir) {\n    // It has a dirname, strip trailing slash\n    dir = dir.substr(0, dir.length - 1);\n  }\n\n  return root + dir;\n};\n\n\nexports.basename = function(path, ext) {\n  var f = splitPath(path)[2];\n  // TODO: make this comparison case-insensitive on windows?\n  if (ext && f.substr(-1 * ext.length) === ext) {\n    f = f.substr(0, f.length - ext.length);\n  }\n  return f;\n};\n\n\nexports.extname = function(path) {\n  return splitPath(path)[3];\n};\n\nfunction filter (xs, f) {\n    if (xs.filter) return xs.filter(f);\n    var res = [];\n    for (var i = 0; i < xs.length; i++) {\n        if (f(xs[i], i, xs)) res.push(xs[i]);\n    }\n    return res;\n}\n\n// String.prototype.substr - negative index don't work in IE8\nvar substr = 'ab'.substr(-1) === 'b'\n    ? function (str, start, len) { return str.substr(start, len) }\n    : function (str, start, len) {\n        if (start < 0) start = str.length + start;\n        return str.substr(start, len);\n    }\n;\n"]}